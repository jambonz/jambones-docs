{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to jambonz jambonz is a self-hosted, \"bring your own everything\" open source CPaaS platform, developed by the creator of the drachtio open source sip server. Unlike those fancy-pants CPaaS services, jambonz is designed to be: 100% open source - the entire project is public on github.com/jambonz (all of it!) Easy to self-host - one-click to run on the infrastructure of your choice Privacy-centric - customer data is never stored by the platform Multi-tenant - good for providers and larger orgs Features All the usual telephony controls - dial, gather DTMF, leave, park, hangup Media control: text-to-speech (TTS) and speech-to-text (STT) integrations, using your google and AWS accounts Call controls for audio playback, speech input, transcription Media forwarding via websocket SIP - registration, trunk connectivity, and dialing Applications - define and manage a set of call flows and behaviours JSON based call control REST API for live call control and resource provisioning and management Hierarchical data structure that can handle a variety of deployment scenarios Registrar, Call control, Session Border Control (SBC), API server, and management infrastructure to handle all the features above EC2 AMIs and terraform scripts for launching a jambonz cluster on AWS Anything you want to add - it's an open source project! Who is jambonz for? jambonz is made for: Commercial CPaaS users that want to save costs using their own SIP trunks and speech services rather than paying up-charged rates to a CPaaS provider. Privacy-concerned Businesses with stringent data privacy requirements who wish to avoid exposing their customers' sensitive data to third parties that they can't effectively audit. Developers that want greater control and the ability to add their own features to a CPaaS platform they control. Enterprises with capable IT departments that are already managing most of what is required for a hosted telephony solution (e.g. cloud storage, speech APIs, infrastructure as code, etc) and are starting to wonder why they are paying so much money to a third party for doing the same thing for them Service providers that want a white-label product that they can offer as a branded solution to their customers. Why does jambonz exist? There are a lot of CPaaS providers on the market today, and they all provide a similar set of easy-to-use APIs that allow enterprises to manage their communication services in new and innovative ways. The concept was novel 10 years ago, but does it really require the high prices and loss of control that commercial solutions provide today? jambonz differs from other solutions because it is: a) open source . Oh, and we mean completely open source (none of that \"yes, we have open source, but you really need to think about upgrading to our commercial offering if you're going to be serious about this relationship\", haha). All of the jambonz core software and drachtio is available on github under the MIT License . b) a self-hosted solution: You run it on your own infrastructure. Use your own SIP trunks. Your own storage. Your own cloud speech credentials. Why pay someone to upcharge you for all of that when it's basically a one-click experience to provision all of those yourself in today's world. You know how to click, right? Let's put it this way: ask yourself -- what are you really getting of value from that fancy-pants CPAAS service you're paying for, when you take away all of the integrations that you can easily do yourself? Just a nice API and application processing engine, that's what. So why not get your own telephony API engine (hint, hint: that's jambonz!) and bring your own everything else to the party? Just sayin. c) a radical approach to privacy . None of your customer's personally identifiable information (PII) is stored at rest within the jambonz platform itself. Ever. Recordings or transcriptions that might contain sensitive information such as credit card numbers, HIPAA-related information, or social security numbers are neever stored at rest within the platform itself. How about SIP credentials for devices or webRTC clients that you want to be allow to register with the platform and make phone calls? Sure, we allow all of that but we don't store the credentials -- you do. We never store any SIP credentials that could be hacked or used by others to run up your bill. d) white-labelable . Is that even a word? Well, in any case, jambonz is service-provider friendly -- it can operate in a multi-tenant configuration for service providers that want to provide a hosted service for customers who are interested in enjoying the privacy and other features of jambonz without running their own hardware. How do jambonz applications work? Well, if you are using one of those fancy-pants CPAAS services, then you are already familiar with how this works: A jambonz application controls calls via web callbacks and an HTTP API. The jambonz platform notifies your application of incoming calls and call status changes via web callbacks. Your application provides call control instructions by responding to web callbacks with JSON payloads that include instructions, or by invoking a REST API . Additionally, jambonz supports sip end-user devices and webRTC clients registering with the platform and making and receiving calls. Come on people. We can do this thing! Take the next step, and read on to review the Call Control and management APIs . What's the name mean? The origin of the name jambonz is unclear, but it is rumoured to either be an acronym for: just another mediocre boring object notational exercise in silliness or a nod to an obscure 1980s-era Boston slang term: jambones [jam-b nz] (adverb) : to move fast; with reckless and uncontrolled abandon. Geraint Thomas was going jambones on that descent! Getting started Enough already! I just want to build one of these things and take it for a spin! OK, gotcha - check out a short video showing a soup-to-nuts walkthrough of how to deploy on AWS in 10 minutes or less , or review instructions on how to build on your own infrastructure . Talk to us on our slack channel to ask questions, learn more about jambonz, or find out how to contribute.","title":"Home"},{"location":"#welcome-to-jambonz","text":"jambonz is a self-hosted, \"bring your own everything\" open source CPaaS platform, developed by the creator of the drachtio open source sip server. Unlike those fancy-pants CPaaS services, jambonz is designed to be: 100% open source - the entire project is public on github.com/jambonz (all of it!) Easy to self-host - one-click to run on the infrastructure of your choice Privacy-centric - customer data is never stored by the platform Multi-tenant - good for providers and larger orgs","title":"Welcome to jambonz"},{"location":"#features","text":"All the usual telephony controls - dial, gather DTMF, leave, park, hangup Media control: text-to-speech (TTS) and speech-to-text (STT) integrations, using your google and AWS accounts Call controls for audio playback, speech input, transcription Media forwarding via websocket SIP - registration, trunk connectivity, and dialing Applications - define and manage a set of call flows and behaviours JSON based call control REST API for live call control and resource provisioning and management Hierarchical data structure that can handle a variety of deployment scenarios Registrar, Call control, Session Border Control (SBC), API server, and management infrastructure to handle all the features above EC2 AMIs and terraform scripts for launching a jambonz cluster on AWS Anything you want to add - it's an open source project!","title":"Features"},{"location":"#who-is-jambonz-for","text":"jambonz is made for: Commercial CPaaS users that want to save costs using their own SIP trunks and speech services rather than paying up-charged rates to a CPaaS provider. Privacy-concerned Businesses with stringent data privacy requirements who wish to avoid exposing their customers' sensitive data to third parties that they can't effectively audit. Developers that want greater control and the ability to add their own features to a CPaaS platform they control. Enterprises with capable IT departments that are already managing most of what is required for a hosted telephony solution (e.g. cloud storage, speech APIs, infrastructure as code, etc) and are starting to wonder why they are paying so much money to a third party for doing the same thing for them Service providers that want a white-label product that they can offer as a branded solution to their customers.","title":"Who is jambonz for?"},{"location":"#why-does-jambonz-exist","text":"There are a lot of CPaaS providers on the market today, and they all provide a similar set of easy-to-use APIs that allow enterprises to manage their communication services in new and innovative ways. The concept was novel 10 years ago, but does it really require the high prices and loss of control that commercial solutions provide today? jambonz differs from other solutions because it is: a) open source . Oh, and we mean completely open source (none of that \"yes, we have open source, but you really need to think about upgrading to our commercial offering if you're going to be serious about this relationship\", haha). All of the jambonz core software and drachtio is available on github under the MIT License . b) a self-hosted solution: You run it on your own infrastructure. Use your own SIP trunks. Your own storage. Your own cloud speech credentials. Why pay someone to upcharge you for all of that when it's basically a one-click experience to provision all of those yourself in today's world. You know how to click, right? Let's put it this way: ask yourself -- what are you really getting of value from that fancy-pants CPAAS service you're paying for, when you take away all of the integrations that you can easily do yourself? Just a nice API and application processing engine, that's what. So why not get your own telephony API engine (hint, hint: that's jambonz!) and bring your own everything else to the party? Just sayin. c) a radical approach to privacy . None of your customer's personally identifiable information (PII) is stored at rest within the jambonz platform itself. Ever. Recordings or transcriptions that might contain sensitive information such as credit card numbers, HIPAA-related information, or social security numbers are neever stored at rest within the platform itself. How about SIP credentials for devices or webRTC clients that you want to be allow to register with the platform and make phone calls? Sure, we allow all of that but we don't store the credentials -- you do. We never store any SIP credentials that could be hacked or used by others to run up your bill. d) white-labelable . Is that even a word? Well, in any case, jambonz is service-provider friendly -- it can operate in a multi-tenant configuration for service providers that want to provide a hosted service for customers who are interested in enjoying the privacy and other features of jambonz without running their own hardware.","title":"Why does jambonz exist?"},{"location":"#how-do-jambonz-applications-work","text":"Well, if you are using one of those fancy-pants CPAAS services, then you are already familiar with how this works: A jambonz application controls calls via web callbacks and an HTTP API. The jambonz platform notifies your application of incoming calls and call status changes via web callbacks. Your application provides call control instructions by responding to web callbacks with JSON payloads that include instructions, or by invoking a REST API . Additionally, jambonz supports sip end-user devices and webRTC clients registering with the platform and making and receiving calls. Come on people. We can do this thing! Take the next step, and read on to review the Call Control and management APIs .","title":"How do jambonz applications work?"},{"location":"#whats-the-name-mean","text":"The origin of the name jambonz is unclear, but it is rumoured to either be an acronym for: just another mediocre boring object notational exercise in silliness or a nod to an obscure 1980s-era Boston slang term: jambones [jam-b nz] (adverb) : to move fast; with reckless and uncontrolled abandon. Geraint Thomas was going jambones on that descent!","title":"What's the name mean?"},{"location":"#getting-started","text":"Enough already! I just want to build one of these things and take it for a spin! OK, gotcha - check out a short video showing a soup-to-nuts walkthrough of how to deploy on AWS in 10 minutes or less , or review instructions on how to build on your own infrastructure . Talk to us on our slack channel to ask questions, learn more about jambonz, or find out how to contribute.","title":"Getting started"},{"location":"data/","text":"jambones data architecture jambones is designed to be deployed either by an end-user customer on their own behalf or by a service provider that hosts a jambones platform and provides service to multiple enterprises. The data model therefore distinguishes the following high-level data entities: platform owner - the entity that operates an instance of the jambones platform. service provider - an organization that provides service to one or more enterprises: a single instance of the platform may support multiple service providers. account - the credentials and information for a single enterprise that is using the platform for telephony service. application - a set of defined call control behaviors to apply to calls managed by an account. carrier - a VoIP carrier that provides call origination/termination services and DIDs (aka DDIs or telephone numbers) to customers. sip gateways - the signaling gateways for a carrier. calls - an instance of a phone call that is controlled via a jambones application. registered user - an authenticated sip client that belongs to an account. data element identifiers Instances of data model entities are publicly identified with a unique value known as a \"sid\". The documentation will therefore frequently refer to the following identifiers: Account Sid - identifies an account. Application Sid - identifies an application. Call Sid - identifies a specific call. Parent Call Sid - identifies the call that another call is bridged to. This is not an exhaustive list, since all data elements have a similar unique identifier (e.g. a service provider sid uniqely identifies a service provider, a carrier sid identifies a specific voip carrier, etc). In-memory database We are currently using redis as an in-memory database for transient data such as sip registrations and calls in progress. The database structure is defined below. calls in progress call:{accountSid}:{callSid} - a hash of call data active-call-sids - sorted set of call keys, with score = time of entry Calls in progress are tracked in two related data structures: First, each call is represented in the database as a hash that is keyed by call:{accountSid}:{callSid} . This allows for easy retrieval of individual calls, as well as all calls for an account. The hash contains the same information that is provided with each webhook for the call. Secondly, each call key is then added to a sorted set named active-call-sids . The score associated with each key is its time of entry ( Date.now() ). This allows for easy scanning of keys from oldest to newest when it is necessary to purge them. The reason for having the sorted set is for efficiency when searching for a subset of calls matching a pattern -- most specifically when retrieving all of the calls associated with an account. The SCAN/ZSCAN command in redis is the most efficient and recommended way to do this. The hash data for a new call is initially added with an initial expiry of twelve hours, but when the call ends the expiry is then set to one hour. Thus all call data naturally expires on its own from the database. The call keys in the sorted set are purged periodically by the jambonz-api-server. sip registrations user:{name}@{domain} - a hash of registration data Active sip registrations are represented in the database as a hash that is keyed by user:{name}@{domain} , where \"domain\" is the sip domain associated with an account. The following information is stored in the hash for each registration: the Contact header provided in the REGISTER request the IP:port of the SBC that the user/device registered to the protocol that the user/device is using (i.e., udp, tcp, wss) the actual source IP and port that the SBC received the REGISTER from (usually different than the Contact header since sip devices are often behind a router) The hash data for a registration has an expiry equal to the registration interval granted, so it will naturally expire unless the registration is renewed by the device. When devices are detected as being behind a router or nat device, the registration interval is decreased to 30 seconds to force the device to register frequently in order to keep a pinhole open on the customer router. This is needed in order to to enable incoming calls sent to the device to be able to enter the customer network. conferences conf:{accountSid}:{friendlyName} - a hash of data about an active conference Active conferences (i.e., conferences that are in progress) are represented as a hash that is keyed by the conference name and and account sid (two different accounts may both choose to have a conference named 'sales', for instance, and those will be distinct conferences). The following information is stored in the hash for each currently active conference: sipAddress : the (private) IP address of the feature server that is hosting the conference startTime : the time the conference was started (number of milliseconds elapsed since January 1, 1970 00:00:00 UTC) statusEvents : the conference events that should be reported statusHook : the webhook conference events should be reported to conf:{accountSid}:{friendlyName}:waitlist - a set of URLs There is a waiting list for each conference, which represents the participants that dialed in early and are waiting for the conference to start. Each entry in the set is a URL that is invoked to notify the caller when the conference starts. Conference data is cleared from the database when the conference is destroyed, which happens either when the moderator leaves or the last participant leaves. queues queue:{accountSid}:{friendlyName} - URL Call queues are represented as a list that is named based the queue name and and account sid (two different accounts may both choose to have a queue named 'support', for instance, and those will be distinct queues). The list members are simple strings, each of which is a URL associated to a call that is currently waiting in queue. mysql database A mysql database is used to provision service information related to accounts, SIP gateways and phone numbers that","title":"Data architecture"},{"location":"data/#jambones-data-architecture","text":"jambones is designed to be deployed either by an end-user customer on their own behalf or by a service provider that hosts a jambones platform and provides service to multiple enterprises. The data model therefore distinguishes the following high-level data entities: platform owner - the entity that operates an instance of the jambones platform. service provider - an organization that provides service to one or more enterprises: a single instance of the platform may support multiple service providers. account - the credentials and information for a single enterprise that is using the platform for telephony service. application - a set of defined call control behaviors to apply to calls managed by an account. carrier - a VoIP carrier that provides call origination/termination services and DIDs (aka DDIs or telephone numbers) to customers. sip gateways - the signaling gateways for a carrier. calls - an instance of a phone call that is controlled via a jambones application. registered user - an authenticated sip client that belongs to an account.","title":"jambones data architecture"},{"location":"data/#data-element-identifiers","text":"Instances of data model entities are publicly identified with a unique value known as a \"sid\". The documentation will therefore frequently refer to the following identifiers: Account Sid - identifies an account. Application Sid - identifies an application. Call Sid - identifies a specific call. Parent Call Sid - identifies the call that another call is bridged to. This is not an exhaustive list, since all data elements have a similar unique identifier (e.g. a service provider sid uniqely identifies a service provider, a carrier sid identifies a specific voip carrier, etc).","title":"data element identifiers"},{"location":"data/#in-memory-database","text":"We are currently using redis as an in-memory database for transient data such as sip registrations and calls in progress. The database structure is defined below.","title":"In-memory database"},{"location":"data/#calls-in-progress","text":"call:{accountSid}:{callSid} - a hash of call data active-call-sids - sorted set of call keys, with score = time of entry Calls in progress are tracked in two related data structures: First, each call is represented in the database as a hash that is keyed by call:{accountSid}:{callSid} . This allows for easy retrieval of individual calls, as well as all calls for an account. The hash contains the same information that is provided with each webhook for the call. Secondly, each call key is then added to a sorted set named active-call-sids . The score associated with each key is its time of entry ( Date.now() ). This allows for easy scanning of keys from oldest to newest when it is necessary to purge them. The reason for having the sorted set is for efficiency when searching for a subset of calls matching a pattern -- most specifically when retrieving all of the calls associated with an account. The SCAN/ZSCAN command in redis is the most efficient and recommended way to do this. The hash data for a new call is initially added with an initial expiry of twelve hours, but when the call ends the expiry is then set to one hour. Thus all call data naturally expires on its own from the database. The call keys in the sorted set are purged periodically by the jambonz-api-server.","title":"calls in progress"},{"location":"data/#sip-registrations","text":"user:{name}@{domain} - a hash of registration data Active sip registrations are represented in the database as a hash that is keyed by user:{name}@{domain} , where \"domain\" is the sip domain associated with an account. The following information is stored in the hash for each registration: the Contact header provided in the REGISTER request the IP:port of the SBC that the user/device registered to the protocol that the user/device is using (i.e., udp, tcp, wss) the actual source IP and port that the SBC received the REGISTER from (usually different than the Contact header since sip devices are often behind a router) The hash data for a registration has an expiry equal to the registration interval granted, so it will naturally expire unless the registration is renewed by the device. When devices are detected as being behind a router or nat device, the registration interval is decreased to 30 seconds to force the device to register frequently in order to keep a pinhole open on the customer router. This is needed in order to to enable incoming calls sent to the device to be able to enter the customer network.","title":"sip registrations"},{"location":"data/#conferences","text":"conf:{accountSid}:{friendlyName} - a hash of data about an active conference Active conferences (i.e., conferences that are in progress) are represented as a hash that is keyed by the conference name and and account sid (two different accounts may both choose to have a conference named 'sales', for instance, and those will be distinct conferences). The following information is stored in the hash for each currently active conference: sipAddress : the (private) IP address of the feature server that is hosting the conference startTime : the time the conference was started (number of milliseconds elapsed since January 1, 1970 00:00:00 UTC) statusEvents : the conference events that should be reported statusHook : the webhook conference events should be reported to conf:{accountSid}:{friendlyName}:waitlist - a set of URLs There is a waiting list for each conference, which represents the participants that dialed in early and are waiting for the conference to start. Each entry in the set is a URL that is invoked to notify the caller when the conference starts. Conference data is cleared from the database when the conference is destroyed, which happens either when the moderator leaves or the last participant leaves.","title":"conferences"},{"location":"data/#queues","text":"queue:{accountSid}:{friendlyName} - URL Call queues are represented as a list that is named based the queue name and and account sid (two different accounts may both choose to have a queue named 'support', for instance, and those will be distinct queues). The list members are simple strings, each of which is a URL associated to a call that is currently waiting in queue.","title":"queues"},{"location":"data/#mysql-database","text":"A mysql database is used to provision service information related to accounts, SIP gateways and phone numbers that","title":"mysql database"},{"location":"installing/","text":"Installing jambonz AWS The quickest way to deploy jambonz currently is on AWS using the provided terraform scripts . Review this quickstart video for details. You can have a system up and running on AWS in less than ten minutes. Otherwise.. If you are using your own hardware, or a different hosting provider, there is a little more elbow grease required. Follow the instructions below to create a jambonz deployment consisting of one SBC and one Feature Server. You will also be provisioning a mysql server and a redis server. A. Provision servers You'll need two servers -- one will be the public-facing SBC, while the other will be the feature server. The SBC must have a public address; the Feature Server does not necessarily need a public address, but of course will need connectivity to the SBC, the mysql database, the redis server, and outbound connectivity to the internet in order to complete the install. If desired, you can install mysql and redis on the SBC server, but as long as they are reachable from both the SBC and the Feature Server you'll be fine. We will be using ansible to build up the servers, which means from your laptop you need ssh connectivity to both the SBC and the Feature Server. The base software distribution for both the SBC and the Feature Server should be Debian 9. A vanilla install that includes sudo and python is all that is needed (python is used by ansible , which we will be using to build up the servers in the next step). B. Use ansible to install base software If you don't have ansible installed on your laptop, install it now following these instructions . Check out the following github repos to your laptop: ansible-role-drachtio ansible-role-fsmrf ansible-role-nodejs ansible-role-rtpengine For the SBC, create an ansible playbook that looks like this, and run it: --- - hosts: all become: yes vars: drachtioBranch: develop rtp_engine_version: mr8.5 vars_prompt: - name: cloud_provider prompt: Cloud provider: aws, gcp, azure, digital_ocean default: none private: no roles: - ansible-role-drachtio - ansible-role-nodejs - ansible-role-rtpengine and for the Feature Server, create an ansible playbook that looks like this, and run it: --- - hosts: all become: yes vars: drachtioBranch: develop build_with_grpc: true vars_prompt: - name: cloud_provider prompt: Cloud provider: aws, gcp, azure, digital_ocean default: none private: no roles: - ansible-role-drachtio - ansible-role-nodejs - ansible-role-fsmrf C. Create mysql database You need to install a mysql database server. Example instructions for installing mysql are provided here . Once the mysql server is installed, create a new database named 'jambones' with an associated username 'admin' and a password of your choice. For the remainder of these instructions, we'll assume a password of 'JambonzR0ck$' was assigned, but you may create a password of your own choosing. Once the database and user has been created, then create this schema . Once the database schema has been created, run this database script as well as this database script to seed the database with initial data. D. Create redis server Install redis somewhere in your network by following these instructions and save the redis hostname that you will use to connect to it. E. Configure SBC Your SBC should have both a public IP and a private IP. The public IP needs to be reachable from the internet, while the private IP should be on the internal subnet, and thus reachable by the Feature Server. In the examples below, we assume that the public IP is 190.144.12.220 and the private IP is 192.168.3.11. Your IPs will be different of course, so substitute the correct IPs in the changes below. drachtio configuration In /etc/systemd/system/drachtio.service change this line: ExecStart=/usr/local/bin/drachtio --daemon to this: ExecStart=/usr/local/bin/drachtio --daemon \\ --contact sip:192.168.3.11;transport=udp --external-ip 190.144.12.220 \\ --contact sip:192.168.3.11;transport=tcp \\ --address 0.0.0.0 --port 9022 or , if you plan on enabling Microsoft Teams routing, to this: ExecStart=/usr/local/bin/drachtio --daemon \\ --contact sip:192.168.3.11;transport=udp --external-ip 190.144.12.220 \\ --contact sips:192.168.3.11:5061;transport=tls --external-ip 190.144.12.220 \\ --contact sip:192.168.3.11;transport=tcp \\ --address 0.0.0.0 --port 9022 Then, reload and restart the drachtio server systemctl daemon-reload systemctl restart drachtio After doing that, run systemctl status drachtio and check /var/log/drachtio/drachtio.log to verify that the drachtio server started properly and is listening on the specified IPs and ports. rtpengine configuration In /etc/systemd/system/rtpengine.service change this line: ExecStart=/usr/local/bin/rtpengine --interface 192.168.3.11!192.168.3.11 \\ to this: ExecStart=/usr/local/bin/rtpengine \\ --interface private/192.168.3.11 \\ --interface public/192.168.3.11!190.144.12.220 \\ Then, reload and restart rtpengine systemctl daemon-reload systemctl restart rtpengine After doing that, run systemctl status rtpengine to verify that rtpengine is running with the defined interfaces. Note: rtpengine logs to /var/log/daemon.log . Install drachtio apps Choose a user to install the drachtio applications under -- the instructions below assume the admin user; if you use a different user than edit the instructions accordingly (note: the user must have sudo priviledges). Execute the following commands from the home directory of the install user: mkdir apps cd $_ git clone https://github.com/jambonz/sbc-outbound.git git clone https://github.com/jambonz/sbc-inbound.git git clone https://github.com/jambonz/sbc-registrar.git git clone https://github.com/jambonz/sbc-call-router.git git clone https://github.com/jambonz/jambonz-api-server.git git clone https://github.com/jambonz/jambonz-webapp.git cd sbc-inbound sudo npm install --unsafe-perm cd ../sbc-outbound sudo npm install --unsafe-perm cd ../sbc-registrar sudo npm install --unsafe-perm cd ../sbc-call-router sudo npm install --unsafe-perm cd ../jambonz-api-server sudo npm install --unsafe-perm cd ../jambonz-webapp sudo npm install --unsafe-perm npm run build sudo -u admin bash -c pm2 install pm2-logrotate sudo -u admin bash -c pm2 set pm2-logrotate:max_size 1G sudo -u admin bash -c pm2 set pm2-logrotate:retain 5 sudo -u admin bash -c pm2 set pm2-logrotate:compress true sudo chown -R admin:admin /home/admin/apps Next, edit this file: ~/apps/jambonz-webapp/.env . Change this: REACT_APP_API_BASE_URL=http://[ip]:[port]/v1 to this: REACT_APP_API_BASE_URL=http://190.144.12.220:3000/v1 Note: again, substitute the public IP of your own SBC in the above Next, copy this file below into ~/apps/ecosystem.config.js . Note: Make sure to edit the file to have the correct connectivity information for your mysql and redis servers, and also if you have installed under a user other than 'admin' make sure to update the file paths accordingly (e.g. in the properties below such as 'cwd', 'out_file' etc). module.exports = { apps: [{ name: 'jambonz-api-server', cwd: '/home/admin/apps/jambonz-api-server', script: 'app.js', out_file: '/home/admin/.pm2/logs/jambonz-api-server.log', err_file: '/home/admin/.pm2/logs/jambonz-api-server.log', combine_logs: true, instance_var: 'INSTANCE_ID', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, JAMBONES_LOGLEVEL: 'info', JAMBONE_API_VERSION: 'v1', JAMBONES_CLUSTER_ID: 'jb', HTTP_PORT: 3000 }, }, { name: 'sbc-call-router', cwd: '/home/admin/apps/sbc-call-router', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-call-router.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-call-router.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', HTTP_PORT: 4000, JAMBONES_INBOUND_ROUTE: '127.0.0.1:4002', JAMBONES_OUTBOUND_ROUTE: '127.0.0.1:4003', JAMBONZ_TAGGED_INBOUND: 1, JAMBONES_NETWORK_CIDR: '192.168.0.0/16' } }, { name: 'sbc-registrar', cwd: '/home/admin/apps/sbc-registrar', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-registrar.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-registrar.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_LOGLEVEL: 'info', DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, } }, { name: 'sbc-outbound', cwd: '/home/admin/apps/sbc-outbound', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-outbound.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-outbound.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_LOGLEVEL: 'info', DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_RTPENGINES: '127.0.0.1:22222', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379 } }, { name: 'sbc-inbound', cwd: '/home/admin/apps/sbc-inbound', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-inbound.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-inbound.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_LOGLEVEL: 'info', DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_RTPENGINES: '127.0.0.1:22222', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, JAMBONES_CLUSTER_ID: 'jb' } }, { name: 'jambonz-webapp', script: 'npm', cwd: '/home/admin/apps/jambonz-webapp', args: 'run serve' } ] }; Open the following ports on the server SBC traffic allowed in ports transport description 3000 tcp REST API 3001 tcp provisioning GUI 5060 udp sip over udp 5060 tcp sip over tcp 5061 tcp sip over tls 4433 tcp sip over wss 40000-60000 udp rtp Next, ssh into the server and run the following command: JAMBONES_MYSQL_HOST= your-mysql-host \\ JAMBONES_MYSQL_USER=admin \\ JAMBONES_MYSQL_PASSWORD=JambonzR0ck$ \\ JAMBONES_MYSQL_DATABASE=jambones \\ /home/admin/apps/jambonz-api-server/db/reset_admin_password.js This is a security measure to randomize some of the initial seed data in the mysql database. Next, start the applications and configure them to restart on boot: sudo -u admin bash -c pm2 start /home/admin/apps/ecosystem.config.js sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u admin --hp /home/admin sudo -u admin bash -c pm2 save sudo systemctl enable pm2-admin.service Check to be sure they are running: pm2 list You should see output similar to this: admin@ip-172-31-32-10:~$ pm2 list \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 name \u2502 namespace \u2502 version \u2502 mode \u2502 pid \u2502 uptime \u2502 \u21ba \u2502 status \u2502 cpu \u2502 mem \u2502 user \u2502 watching \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 7 \u2502 jambonz-api-server \u2502 default \u2502 1.1.7 \u2502 fork \u2502 4494 \u2502 4s \u2502 0 \u2502 online \u2502 30.4% \u2502 104.7mb \u2502 admin \u2502 disabled \u2502 \u2502 12 \u2502 jambonz-webapp \u2502 default \u2502 N/A \u2502 fork \u2502 4540 \u2502 4s \u2502 0 \u2502 online \u2502 7.9% \u2502 49.9mb \u2502 admin \u2502 disabled \u2502 \u2502 8 \u2502 sbc-call-router \u2502 default \u2502 0.0.1 \u2502 fork \u2502 4500 \u2502 4s \u2502 0 \u2502 online \u2502 3.7% \u2502 43.8mb \u2502 admin \u2502 disabled \u2502 \u2502 11 \u2502 sbc-inbound \u2502 default \u2502 0.3.5 \u2502 fork \u2502 4538 \u2502 4s \u2502 0 \u2502 online \u2502 24.1% \u2502 100.3mb \u2502 admin \u2502 disabled \u2502 \u2502 10 \u2502 sbc-outbound \u2502 default \u2502 0.4.2 \u2502 fork \u2502 4515 \u2502 4s \u2502 0 \u2502 online \u2502 13.9% \u2502 83.3mb \u2502 admin \u2502 disabled \u2502 \u2502 9 \u2502 sbc-registrar \u2502 default \u2502 0.1.7 \u2502 fork \u2502 4512 \u2502 4s \u2502 0 \u2502 online \u2502 13.6% \u2502 83.0mb \u2502 admin \u2502 disabled \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Module \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 module \u2502 version \u2502 pid \u2502 status \u2502 \u21ba \u2502 cpu \u2502 mem \u2502 user \u2502 \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 pm2-logrotate \u2502 2.7.0 \u2502 28461 \u2502 online \u2502 1 \u2502 0.3% \u2502 80.7mb \u2502 admin \u2502 \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, in your browser, navigate to http:// sbc-public-ip :3001 . You should get a login page to the SBC. Log in with admin/admin. You will be asked to change the password and then be guided through an initial 3-step setup process to configuring your account, application, and SIP trunking provider. F. Configure Feature Server Open the following ports on the server Feature server traffic allowed in Note: all of the ports below need to be open for traffic sent from a source IP that is within the local network. Traffic from the internet to these ports can be blocked. ports transport description 3000 tcp REST API 5060 udp sip 5060 tcp sip 5080 udp freeswitch sip 5080 tcp freeswitch sip 25000 - 40000 udp rtp In the file /usr/local/freeswitch/conf/autoload_configs/switch.conf.xml set the rtp port range to be 25000 through 39000 by editing the 'rtp-start-port' and 'rtp-end-port' as follows: !-- RTP port range -- param name= rtp-start-port value= 25000 / param name= rtp-end-port value= 39000 / In the file /usr/local/freeswitch/conf/autoload_configs/event_socket.conf.xml replace the contents with: configuration name= event_socket.conf description= Socket Client settings param name= nat-map value= false / param name= listen-ip value= 0.0.0.0 / param name= listen-port value= 8021 / param name= password value= JambonzR0ck$ / param name= apply-inbound-acl value= socket_acl / /settings /configuration Note: Feel free to choose a different password if you like. In the file /etc/systemd/system/freeswitch.service make sure the following Environment variables are set: [Service] ; service Type=forking PIDFile=/usr/local/freeswitch/run/freeswitch.pid EnvironmentFile=-/etc/default/freeswitch Environment= MOD_AUDIO_FORK_SUBPROTOCOL_NAME=audio.jambonz.org Environment= MOD_AUDIO_FORK_SERVICE_THREADS=1 Environment= MOD_AUDIO_FORK_BUFFER_SECS=3 Environment= LD_LIBRARY_PATH=/usr/local/lib Environment= GOOGLE_APPLICATION_CREDENTIALS=/home/admin/credentials/gcp.json ExecStart=/usr/local/freeswitch/bin/freeswitch -nc -nonat Install drachtio apps Choose a user to install the drachtio applications under -- the instructions below assume the admin user; if you use a different user than edit the instructions accordingly (note: the user must have sudo priviledges). Execute the following commands from the home directory of the install user: mkdir apps credentials cd apps git clone https://github.com/jambonz/jambonz-feature-server.git git clone https://github.com/jambonz/fsw-clear-old-calls.git cd jambonz-feature-server sudo npm install --unsafe-perm cd ../fsw-clear-old-calls npm install sudo npm install -g . echo 0 * * * * root fsw-clear-old-calls --password JambonzR0ck$ /var/log/fsw-clear-old-calls.log 2 1 | sudo tee -a /etc/crontab sudo -u admin bash -c pm2 install pm2-logrotate sudo -u admin bash -c pm2 set pm2-logrotate:max_size 1G sudo -u admin bash -c pm2 set pm2-logrotate:retain 5 sudo -u admin bash -c pm2 set pm2-logrotate:compress true sudo chown -R admin:admin /home/admin/apps Note: if you chose a different Freeswitch password, make sure to adjust the crontab entry above to use that password. Next, copy your google service credentials json file into /home/admin/credentials/gcp.json . Note that this is referenced from the Environment variable that you set in the freeswitch systemd service file. Next, copy this file below into ~/apps/ecosystem.config.js . Note: Make sure to edit the file below to have the correct information for: your mysql and redis server hosts, your AWS access key, secret access key, and region your mysql and freeswitch passwords, if different than below the IP address of the SBC on the internal network, the network CIDR of the internal network, and if you have installed under a user other than 'admin' make sure to update the file paths accordingly (e.g. in the properties below such as 'cwd', 'out_file' etc). module.exports = { apps : [ { name: 'jambonz-feature-server', cwd: '/home/admin/apps/jambonz-feature-server', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-feature-server.log', err_file: '/home/admin/.pm2/logs/jambonz-feature-server.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', GOOGLE_APPLICATION_CREDENTIALS: '/home/admin/credentials/gcp.json', AWS_ACCESS_KEY_ID: ' your-aws-access-key-id ', AWS_SECRET_ACCESS_KEY: ' your-aws-secret-access-key ', AWS_REGION: 'us-west-1', JAMBONES_NETWORK_CIDR: '192.168.0.0/16', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, JAMBONES_LOGLEVEL: 'info', HTTP_PORT: 3000, DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_SBCS: '192.168.3.11', JAMBONES_FEATURE_SERVERS: '127.0.0.1:9022:cymru', JAMBONES_FREESWITCH: '127.0.0.1:8021:JambonzR0ck$' } }] }; Next, start the applications and configure them to restart on boot: sudo -u admin bash -c pm2 start /home/admin/apps/ecosystem.config.js sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u admin --hp /home/admin sudo -u admin bash -c pm2 save sudo systemctl enable pm2-admin.service Check to be sure they are running: pm2 list You should see output similar to this: admin@ip-172-31-33-250:~$ pm2 list \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 name \u2502 namespace \u2502 version \u2502 mode \u2502 pid \u2502 uptime \u2502 \u21ba \u2502 status \u2502 cpu \u2502 mem \u2502 user \u2502 watching \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 jambonz-feature-server \u2502 default \u2502 0.2.3 \u2502 fork \u2502 22438 \u2502 47h \u2502 6 \u2502 online \u2502 0.2% \u2502 85.4mb \u2502 admin \u2502 disabled \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Module \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 module \u2502 version \u2502 pid \u2502 status \u2502 \u21ba \u2502 cpu \u2502 mem \u2502 user \u2502 \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 pm2-logrotate \u2502 2.7.0 \u2502 1015 \u2502 online \u2502 0 \u2502 0.1% \u2502 66.4mb \u2502 admin \u2502 \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, restart the drachtio and freeswitch services: sudo systemctl daemon-reload sudo systemctl restart freeswitch sudo systemctl restart drachtio For good measure, restart the drachtio apps as well pm2 restart /home/admin/apps/ecosystem.config.js Now you should have a running system. Verify the drachtio server and freeswitch are running sudo systemctl status drachtio sudo systemctl status freeswitch Verify the apps are running and are not logging any errors: pm2 list pm2 log Finally, tail the /var/log/drachtio/drachtio.log file and verify that sip OPTIONS requests are being sent to the SBC and are receiving a 200 OK response. At this point, your system is ready for testing.","title":"Installing"},{"location":"installing/#installing-jambonz","text":"","title":"Installing jambonz"},{"location":"installing/#aws","text":"The quickest way to deploy jambonz currently is on AWS using the provided terraform scripts . Review this quickstart video for details. You can have a system up and running on AWS in less than ten minutes.","title":"AWS"},{"location":"installing/#otherwise","text":"If you are using your own hardware, or a different hosting provider, there is a little more elbow grease required. Follow the instructions below to create a jambonz deployment consisting of one SBC and one Feature Server. You will also be provisioning a mysql server and a redis server.","title":"Otherwise.."},{"location":"installing/#a-provision-servers","text":"You'll need two servers -- one will be the public-facing SBC, while the other will be the feature server. The SBC must have a public address; the Feature Server does not necessarily need a public address, but of course will need connectivity to the SBC, the mysql database, the redis server, and outbound connectivity to the internet in order to complete the install. If desired, you can install mysql and redis on the SBC server, but as long as they are reachable from both the SBC and the Feature Server you'll be fine. We will be using ansible to build up the servers, which means from your laptop you need ssh connectivity to both the SBC and the Feature Server. The base software distribution for both the SBC and the Feature Server should be Debian 9. A vanilla install that includes sudo and python is all that is needed (python is used by ansible , which we will be using to build up the servers in the next step).","title":"A. Provision servers"},{"location":"installing/#b-use-ansible-to-install-base-software","text":"If you don't have ansible installed on your laptop, install it now following these instructions . Check out the following github repos to your laptop: ansible-role-drachtio ansible-role-fsmrf ansible-role-nodejs ansible-role-rtpengine For the SBC, create an ansible playbook that looks like this, and run it: --- - hosts: all become: yes vars: drachtioBranch: develop rtp_engine_version: mr8.5 vars_prompt: - name: cloud_provider prompt: Cloud provider: aws, gcp, azure, digital_ocean default: none private: no roles: - ansible-role-drachtio - ansible-role-nodejs - ansible-role-rtpengine and for the Feature Server, create an ansible playbook that looks like this, and run it: --- - hosts: all become: yes vars: drachtioBranch: develop build_with_grpc: true vars_prompt: - name: cloud_provider prompt: Cloud provider: aws, gcp, azure, digital_ocean default: none private: no roles: - ansible-role-drachtio - ansible-role-nodejs - ansible-role-fsmrf","title":"B. Use ansible to install base software"},{"location":"installing/#c-create-mysql-database","text":"You need to install a mysql database server. Example instructions for installing mysql are provided here . Once the mysql server is installed, create a new database named 'jambones' with an associated username 'admin' and a password of your choice. For the remainder of these instructions, we'll assume a password of 'JambonzR0ck$' was assigned, but you may create a password of your own choosing. Once the database and user has been created, then create this schema . Once the database schema has been created, run this database script as well as this database script to seed the database with initial data.","title":"C. Create mysql database"},{"location":"installing/#d-create-redis-server","text":"Install redis somewhere in your network by following these instructions and save the redis hostname that you will use to connect to it.","title":"D. Create redis server"},{"location":"installing/#e-configure-sbc","text":"Your SBC should have both a public IP and a private IP. The public IP needs to be reachable from the internet, while the private IP should be on the internal subnet, and thus reachable by the Feature Server. In the examples below, we assume that the public IP is 190.144.12.220 and the private IP is 192.168.3.11. Your IPs will be different of course, so substitute the correct IPs in the changes below.","title":"E. Configure SBC"},{"location":"installing/#drachtio-configuration","text":"In /etc/systemd/system/drachtio.service change this line: ExecStart=/usr/local/bin/drachtio --daemon to this: ExecStart=/usr/local/bin/drachtio --daemon \\ --contact sip:192.168.3.11;transport=udp --external-ip 190.144.12.220 \\ --contact sip:192.168.3.11;transport=tcp \\ --address 0.0.0.0 --port 9022 or , if you plan on enabling Microsoft Teams routing, to this: ExecStart=/usr/local/bin/drachtio --daemon \\ --contact sip:192.168.3.11;transport=udp --external-ip 190.144.12.220 \\ --contact sips:192.168.3.11:5061;transport=tls --external-ip 190.144.12.220 \\ --contact sip:192.168.3.11;transport=tcp \\ --address 0.0.0.0 --port 9022 Then, reload and restart the drachtio server systemctl daemon-reload systemctl restart drachtio After doing that, run systemctl status drachtio and check /var/log/drachtio/drachtio.log to verify that the drachtio server started properly and is listening on the specified IPs and ports.","title":"drachtio configuration"},{"location":"installing/#rtpengine-configuration","text":"In /etc/systemd/system/rtpengine.service change this line: ExecStart=/usr/local/bin/rtpengine --interface 192.168.3.11!192.168.3.11 \\ to this: ExecStart=/usr/local/bin/rtpengine \\ --interface private/192.168.3.11 \\ --interface public/192.168.3.11!190.144.12.220 \\ Then, reload and restart rtpengine systemctl daemon-reload systemctl restart rtpengine After doing that, run systemctl status rtpengine to verify that rtpengine is running with the defined interfaces. Note: rtpengine logs to /var/log/daemon.log .","title":"rtpengine configuration"},{"location":"installing/#install-drachtio-apps","text":"Choose a user to install the drachtio applications under -- the instructions below assume the admin user; if you use a different user than edit the instructions accordingly (note: the user must have sudo priviledges). Execute the following commands from the home directory of the install user: mkdir apps cd $_ git clone https://github.com/jambonz/sbc-outbound.git git clone https://github.com/jambonz/sbc-inbound.git git clone https://github.com/jambonz/sbc-registrar.git git clone https://github.com/jambonz/sbc-call-router.git git clone https://github.com/jambonz/jambonz-api-server.git git clone https://github.com/jambonz/jambonz-webapp.git cd sbc-inbound sudo npm install --unsafe-perm cd ../sbc-outbound sudo npm install --unsafe-perm cd ../sbc-registrar sudo npm install --unsafe-perm cd ../sbc-call-router sudo npm install --unsafe-perm cd ../jambonz-api-server sudo npm install --unsafe-perm cd ../jambonz-webapp sudo npm install --unsafe-perm npm run build sudo -u admin bash -c pm2 install pm2-logrotate sudo -u admin bash -c pm2 set pm2-logrotate:max_size 1G sudo -u admin bash -c pm2 set pm2-logrotate:retain 5 sudo -u admin bash -c pm2 set pm2-logrotate:compress true sudo chown -R admin:admin /home/admin/apps Next, edit this file: ~/apps/jambonz-webapp/.env . Change this: REACT_APP_API_BASE_URL=http://[ip]:[port]/v1 to this: REACT_APP_API_BASE_URL=http://190.144.12.220:3000/v1 Note: again, substitute the public IP of your own SBC in the above Next, copy this file below into ~/apps/ecosystem.config.js . Note: Make sure to edit the file to have the correct connectivity information for your mysql and redis servers, and also if you have installed under a user other than 'admin' make sure to update the file paths accordingly (e.g. in the properties below such as 'cwd', 'out_file' etc). module.exports = { apps: [{ name: 'jambonz-api-server', cwd: '/home/admin/apps/jambonz-api-server', script: 'app.js', out_file: '/home/admin/.pm2/logs/jambonz-api-server.log', err_file: '/home/admin/.pm2/logs/jambonz-api-server.log', combine_logs: true, instance_var: 'INSTANCE_ID', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, JAMBONES_LOGLEVEL: 'info', JAMBONE_API_VERSION: 'v1', JAMBONES_CLUSTER_ID: 'jb', HTTP_PORT: 3000 }, }, { name: 'sbc-call-router', cwd: '/home/admin/apps/sbc-call-router', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-call-router.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-call-router.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', HTTP_PORT: 4000, JAMBONES_INBOUND_ROUTE: '127.0.0.1:4002', JAMBONES_OUTBOUND_ROUTE: '127.0.0.1:4003', JAMBONZ_TAGGED_INBOUND: 1, JAMBONES_NETWORK_CIDR: '192.168.0.0/16' } }, { name: 'sbc-registrar', cwd: '/home/admin/apps/sbc-registrar', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-registrar.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-registrar.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_LOGLEVEL: 'info', DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, } }, { name: 'sbc-outbound', cwd: '/home/admin/apps/sbc-outbound', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-outbound.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-outbound.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_LOGLEVEL: 'info', DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_RTPENGINES: '127.0.0.1:22222', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379 } }, { name: 'sbc-inbound', cwd: '/home/admin/apps/sbc-inbound', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-sbc-inbound.log', err_file: '/home/admin/.pm2/logs/jambonz-sbc-inbound.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', JAMBONES_LOGLEVEL: 'info', DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_RTPENGINES: '127.0.0.1:22222', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, JAMBONES_CLUSTER_ID: 'jb' } }, { name: 'jambonz-webapp', script: 'npm', cwd: '/home/admin/apps/jambonz-webapp', args: 'run serve' } ] }; Open the following ports on the server SBC traffic allowed in ports transport description 3000 tcp REST API 3001 tcp provisioning GUI 5060 udp sip over udp 5060 tcp sip over tcp 5061 tcp sip over tls 4433 tcp sip over wss 40000-60000 udp rtp Next, ssh into the server and run the following command: JAMBONES_MYSQL_HOST= your-mysql-host \\ JAMBONES_MYSQL_USER=admin \\ JAMBONES_MYSQL_PASSWORD=JambonzR0ck$ \\ JAMBONES_MYSQL_DATABASE=jambones \\ /home/admin/apps/jambonz-api-server/db/reset_admin_password.js This is a security measure to randomize some of the initial seed data in the mysql database. Next, start the applications and configure them to restart on boot: sudo -u admin bash -c pm2 start /home/admin/apps/ecosystem.config.js sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u admin --hp /home/admin sudo -u admin bash -c pm2 save sudo systemctl enable pm2-admin.service Check to be sure they are running: pm2 list You should see output similar to this: admin@ip-172-31-32-10:~$ pm2 list \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 name \u2502 namespace \u2502 version \u2502 mode \u2502 pid \u2502 uptime \u2502 \u21ba \u2502 status \u2502 cpu \u2502 mem \u2502 user \u2502 watching \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 7 \u2502 jambonz-api-server \u2502 default \u2502 1.1.7 \u2502 fork \u2502 4494 \u2502 4s \u2502 0 \u2502 online \u2502 30.4% \u2502 104.7mb \u2502 admin \u2502 disabled \u2502 \u2502 12 \u2502 jambonz-webapp \u2502 default \u2502 N/A \u2502 fork \u2502 4540 \u2502 4s \u2502 0 \u2502 online \u2502 7.9% \u2502 49.9mb \u2502 admin \u2502 disabled \u2502 \u2502 8 \u2502 sbc-call-router \u2502 default \u2502 0.0.1 \u2502 fork \u2502 4500 \u2502 4s \u2502 0 \u2502 online \u2502 3.7% \u2502 43.8mb \u2502 admin \u2502 disabled \u2502 \u2502 11 \u2502 sbc-inbound \u2502 default \u2502 0.3.5 \u2502 fork \u2502 4538 \u2502 4s \u2502 0 \u2502 online \u2502 24.1% \u2502 100.3mb \u2502 admin \u2502 disabled \u2502 \u2502 10 \u2502 sbc-outbound \u2502 default \u2502 0.4.2 \u2502 fork \u2502 4515 \u2502 4s \u2502 0 \u2502 online \u2502 13.9% \u2502 83.3mb \u2502 admin \u2502 disabled \u2502 \u2502 9 \u2502 sbc-registrar \u2502 default \u2502 0.1.7 \u2502 fork \u2502 4512 \u2502 4s \u2502 0 \u2502 online \u2502 13.6% \u2502 83.0mb \u2502 admin \u2502 disabled \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Module \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 module \u2502 version \u2502 pid \u2502 status \u2502 \u21ba \u2502 cpu \u2502 mem \u2502 user \u2502 \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 pm2-logrotate \u2502 2.7.0 \u2502 28461 \u2502 online \u2502 1 \u2502 0.3% \u2502 80.7mb \u2502 admin \u2502 \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, in your browser, navigate to http:// sbc-public-ip :3001 . You should get a login page to the SBC. Log in with admin/admin. You will be asked to change the password and then be guided through an initial 3-step setup process to configuring your account, application, and SIP trunking provider.","title":"Install drachtio apps"},{"location":"installing/#f-configure-feature-server","text":"Open the following ports on the server Feature server traffic allowed in Note: all of the ports below need to be open for traffic sent from a source IP that is within the local network. Traffic from the internet to these ports can be blocked. ports transport description 3000 tcp REST API 5060 udp sip 5060 tcp sip 5080 udp freeswitch sip 5080 tcp freeswitch sip 25000 - 40000 udp rtp In the file /usr/local/freeswitch/conf/autoload_configs/switch.conf.xml set the rtp port range to be 25000 through 39000 by editing the 'rtp-start-port' and 'rtp-end-port' as follows: !-- RTP port range -- param name= rtp-start-port value= 25000 / param name= rtp-end-port value= 39000 / In the file /usr/local/freeswitch/conf/autoload_configs/event_socket.conf.xml replace the contents with: configuration name= event_socket.conf description= Socket Client settings param name= nat-map value= false / param name= listen-ip value= 0.0.0.0 / param name= listen-port value= 8021 / param name= password value= JambonzR0ck$ / param name= apply-inbound-acl value= socket_acl / /settings /configuration Note: Feel free to choose a different password if you like. In the file /etc/systemd/system/freeswitch.service make sure the following Environment variables are set: [Service] ; service Type=forking PIDFile=/usr/local/freeswitch/run/freeswitch.pid EnvironmentFile=-/etc/default/freeswitch Environment= MOD_AUDIO_FORK_SUBPROTOCOL_NAME=audio.jambonz.org Environment= MOD_AUDIO_FORK_SERVICE_THREADS=1 Environment= MOD_AUDIO_FORK_BUFFER_SECS=3 Environment= LD_LIBRARY_PATH=/usr/local/lib Environment= GOOGLE_APPLICATION_CREDENTIALS=/home/admin/credentials/gcp.json ExecStart=/usr/local/freeswitch/bin/freeswitch -nc -nonat","title":"F. Configure Feature Server"},{"location":"installing/#install-drachtio-apps_1","text":"Choose a user to install the drachtio applications under -- the instructions below assume the admin user; if you use a different user than edit the instructions accordingly (note: the user must have sudo priviledges). Execute the following commands from the home directory of the install user: mkdir apps credentials cd apps git clone https://github.com/jambonz/jambonz-feature-server.git git clone https://github.com/jambonz/fsw-clear-old-calls.git cd jambonz-feature-server sudo npm install --unsafe-perm cd ../fsw-clear-old-calls npm install sudo npm install -g . echo 0 * * * * root fsw-clear-old-calls --password JambonzR0ck$ /var/log/fsw-clear-old-calls.log 2 1 | sudo tee -a /etc/crontab sudo -u admin bash -c pm2 install pm2-logrotate sudo -u admin bash -c pm2 set pm2-logrotate:max_size 1G sudo -u admin bash -c pm2 set pm2-logrotate:retain 5 sudo -u admin bash -c pm2 set pm2-logrotate:compress true sudo chown -R admin:admin /home/admin/apps Note: if you chose a different Freeswitch password, make sure to adjust the crontab entry above to use that password. Next, copy your google service credentials json file into /home/admin/credentials/gcp.json . Note that this is referenced from the Environment variable that you set in the freeswitch systemd service file. Next, copy this file below into ~/apps/ecosystem.config.js . Note: Make sure to edit the file below to have the correct information for: your mysql and redis server hosts, your AWS access key, secret access key, and region your mysql and freeswitch passwords, if different than below the IP address of the SBC on the internal network, the network CIDR of the internal network, and if you have installed under a user other than 'admin' make sure to update the file paths accordingly (e.g. in the properties below such as 'cwd', 'out_file' etc). module.exports = { apps : [ { name: 'jambonz-feature-server', cwd: '/home/admin/apps/jambonz-feature-server', script: 'app.js', instance_var: 'INSTANCE_ID', out_file: '/home/admin/.pm2/logs/jambonz-feature-server.log', err_file: '/home/admin/.pm2/logs/jambonz-feature-server.log', exec_mode: 'fork', instances: 1, autorestart: true, watch: false, max_memory_restart: '1G', env: { NODE_ENV: 'production', GOOGLE_APPLICATION_CREDENTIALS: '/home/admin/credentials/gcp.json', AWS_ACCESS_KEY_ID: ' your-aws-access-key-id ', AWS_SECRET_ACCESS_KEY: ' your-aws-secret-access-key ', AWS_REGION: 'us-west-1', JAMBONES_NETWORK_CIDR: '192.168.0.0/16', JAMBONES_MYSQL_HOST: ' your-mysql-host ', JAMBONES_MYSQL_USER: 'admin', JAMBONES_MYSQL_PASSWORD: 'JambonzR0ck$', JAMBONES_MYSQL_DATABASE: 'jambones', JAMBONES_MYSQL_CONNECTION_LIMIT: 10, JAMBONES_REDIS_HOST: ' your-redis-host ', JAMBONES_REDIS_PORT: 6379, JAMBONES_LOGLEVEL: 'info', HTTP_PORT: 3000, DRACHTIO_HOST: '127.0.0.1', DRACHTIO_PORT: 9022, DRACHTIO_SECRET: 'cymru', JAMBONES_SBCS: '192.168.3.11', JAMBONES_FEATURE_SERVERS: '127.0.0.1:9022:cymru', JAMBONES_FREESWITCH: '127.0.0.1:8021:JambonzR0ck$' } }] }; Next, start the applications and configure them to restart on boot: sudo -u admin bash -c pm2 start /home/admin/apps/ecosystem.config.js sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u admin --hp /home/admin sudo -u admin bash -c pm2 save sudo systemctl enable pm2-admin.service Check to be sure they are running: pm2 list You should see output similar to this: admin@ip-172-31-33-250:~$ pm2 list \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 name \u2502 namespace \u2502 version \u2502 mode \u2502 pid \u2502 uptime \u2502 \u21ba \u2502 status \u2502 cpu \u2502 mem \u2502 user \u2502 watching \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 jambonz-feature-server \u2502 default \u2502 0.2.3 \u2502 fork \u2502 22438 \u2502 47h \u2502 6 \u2502 online \u2502 0.2% \u2502 85.4mb \u2502 admin \u2502 disabled \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Module \u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 id \u2502 module \u2502 version \u2502 pid \u2502 status \u2502 \u21ba \u2502 cpu \u2502 mem \u2502 user \u2502 \u251c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 0 \u2502 pm2-logrotate \u2502 2.7.0 \u2502 1015 \u2502 online \u2502 0 \u2502 0.1% \u2502 66.4mb \u2502 admin \u2502 \u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Finally, restart the drachtio and freeswitch services: sudo systemctl daemon-reload sudo systemctl restart freeswitch sudo systemctl restart drachtio For good measure, restart the drachtio apps as well pm2 restart /home/admin/apps/ecosystem.config.js Now you should have a running system. Verify the drachtio server and freeswitch are running sudo systemctl status drachtio sudo systemctl status freeswitch Verify the apps are running and are not logging any errors: pm2 list pm2 log Finally, tail the /var/log/drachtio/drachtio.log file and verify that sip OPTIONS requests are being sent to the SBC and are receiving a 200 OK response. At this point, your system is ready for testing.","title":"Install drachtio apps"},{"location":"jambonz/","text":"Overview jambonz is a specification for issuing call control commands via JSON payloads over HTTP connections. These messages are sent from your application in response to web callbacks from a jambonz call control server, and they provide jambonz with your instructions on how to handle a call. When an incoming call is received by the platform, jambonz makes an HTTP request to the URL endpoint that is configured for that called number. Outbound calls that are initiated by the REST API are controlled in a similar way -- when invoking the REST API to launch a call, you provide a web callback url and in your response to the subsequent HTTP GET or POST to that url you then return a JSON payload describing the application that should govern the outbound call. Basic JSON message structure The JSON payload (aka the \"application\") that you provide in response to a callback must be an array of objects, with each object describing a task that the platform shall perform. These tasks are executed sequentially in the order they appear in the array. Each task is identified by a verb (e.g. \"dial\", \"gather\", \"hangup\" etc) with associated detail and these verbs are described in more detail below. If the caller hangs up during the execution of an application for that call, the current task is allowed to complete and any remaining tasks in the application are ignored. Through additional callbacks that may be invoked during the execution of an application (typically as a result of those verbs which have an \"action\" property callback), the current application may be replaced with a new JSON application document. In such a case, the new document begins executing, and any remaining tasks in the original document are discarded. Each task object in the JSON array must include a \"verb\" property that describes the action to take. Any additional information that the task needs to operate are provided as properties as well, e.g.: { verb : say , text : Hi there! Please leave a message at the tone and we will get back to you shortly. , synthesizer : { vendor : google , language : en-US , gender : FEMALE } } Some verbs allow other verbs to be nested; e.g. \"gather\" can have a nested \"say\" command in order to play a prompt and collect a response in one command: { verb : gather , actionHook : /gatherCardNumber , input : [ speech , dtmf ], timeout : 16, numDigits : 6, recognizer : { vendor : google , language : en-US }, say : { text : Please say or enter your six digit card number now , synthesizer : { vendor : google , language : en-US , gender : FEMALE } } } Altogether then, a simple example application which provides the basics of a voicemail application with transcription would look like this: [ { verb : say , text : Hi there! Please leave a message at the tone and we will get back to you shortly. Thanks, and have a great day! }, { verb : listen , actionHook : http://example.com/voicemail , url : http://ws.example.com , finishOnKey : # , metadata : { topic : voicemail }, mixType : mono , playBeep : true, timeout : 20, transcribe : { transcriptionHook : /transcription } }, { verb : say , text : Thanks for your message. We'll get back to you } ] Hey, did you see what we did there? It's a voicemail application, but where is the recording url? How do you retrieve the recording after the call? There is none, and you don't. Let's rethink this: Instead of making a recording -- which exposes your customer's PII since we now have to store sensitive data at rest in the platform -- how's about we instead send you a real-time audio stream over a secure websocket connection while the call is proceeding. Annotate it with any metadata you need for tracking on your end, and we'll send that along as well. Thus, you get the audio in real-time and we don't ever store your customer's sensitive data at rest. Bam. Done. HTTP connection details Each HTTP request that jambonz makes to one of your callbacks will include (at least) the following information either as query arguments (in a GET request) or in the body of the response as a JSON payload (in a POST request): callSid: a unique identifier for the call, in a uuid format. applicationSid: a unique identifier for the jambonz application controlling this call accountSid: a unique identifier for the jambonz account associated with the application direction: the direction of the call, either 'inbound' or 'outbound' from: the calling party number to: the called party number callerId: the caller name, if known callStatus: current status of the call, see table below sipStatus: the most recent sip status code received or generated for the call Additionally, the request MAY include parentCallSid: the callSid of a parent call to this call, if this call is a child call And the initial webhook for a new incoming call will have: originatingSipTrunkName: name of the SIP trunk that originated the call to the platform originatingSipIp: the ip address and port of the sip gateway that originated the call Finally, if you specify to use a POST method for the initial webhook for an incoming call, the JSON payload in that POST will also contain the entire incoming SIP INVITE request details in a 'sip' property (this is not provided if a GET request is used). This can be useful if you need a detailed look at all of the SIP headers or the Session Description Protocol being offered. Note also that the information that jambonz sends you with each HTTP request can be augmented by your application by using the tag verb. You may optionally use HTTP Basic Authentication to protect your endpoints. call status value description trying a new incoming call has arrived or an outbound call has just been sent ringing a 180 Ringing response has been sent or received early-media an early media connection has been established prior to answering the call (183 Session Progress) in-progress call has been answered completed an answered call has ended failed a call attempt failed busy a call attempt failed because the called party returned a busy status no-answer a call attempt failed because it was not answered in time Refer to the Example messages section to see further details. Initial state of incoming calls When the jambonz platform receives a new incoming call, it responds 100 Trying to the INVITE but does not automatically answer the call. It is up to your application to decide how to finally respond to the INVITE. You have some choices here. Your application can: answer the call, which connects the call to a media endpoint that can perform IVR functions on the call, outdial a new call, and bridge the two calls together (i.e use the dial verb), reject the call, with a specified SIP status code and reason, redirect the call (i.e. generating a SIP 302 response back to the caller), or establish an early media connection and play audio to the caller without answering the call. The last is interesting and worthy of further comment. The intent is to let you play audio to callers without necessarily answering the call. You signal this by including an \"earlyMedia\" property with a value of true in the application. When receiving this, the jambonz core will create an early media connection (183 Session Progress) if possible, as shown in the example below. Note: an early media connection will not be possible if the call has already been answered by an earlier verb in the application. In such a scenario, the earlyMedia property is ignored. [ { verb : say , earlyMedia : true, text : Please call back later, we are currently at lunch synthesizer : { vendor : aws , language : en-US , voice : Amy }, { verb : sip:decline , status : 480, headers : { Retry-After : 1800 } } } ] The say, play, gather, listen, and transcribe verbs all support the \"earlyMedia\" property. The dial verb supports a similar feature of not answering the inbound call unless/until the dialed call is answered via the \"answerOnBridge\" property. Speech integration The platform makes use of text-to-speech as well as real-time speech recognition. Both google and AWS/Polly are supported for text to speech. Currently only google is supported for speech to text. Synthesized audio is cached for up to 24 hours, so that if the same {text, language, voice} combination is requested more than once in that period it will be served from cache, reducing speech synthesis costs. A JSON service key file containing GCP credentials for cloud speech services must be downloaded and installed on the jambonz feature servers to enable tts and speech recognition for google. For AWS/Polly, the environment variables AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_REGION must be provided in the server environments where the jambonz-feature-server application is running. As part of the definition of an application, you can set defaults for the language and voice to use for speech synthesis as well as the language to use for speech recognition. These can then be overridden by verbs in the application, by using the 'synthesizer' and 'recognizer' properties./ Webhooks Many of the verbs specify a webhook that will be called when the verb completes, or has some information to deliver to your application. These verbs contain a property that allow you to configure that webhook. By convention, the property name will always end in \"Hook\"; e.g \"actionHook\", \"dtmfHook\", and so on. You can either specify the webhook as a simple string specifying a url: actionHook : https://my.appserver.com/results or a relative url actionHook : /results In the latter case, the base url of the application will be applied. Alternatively, you can provide an object containing a url (required) and optional method and basic authentication parameters, e.g.: actionHook : { url : https://my.appserver.com/results , method : GET , username : foo , password : bar } In the verb descriptions below, whenever we indicate a property is a webhook we are referring to this syntax. Supported Verbs Each of the supported verbs are described below. conference The conference verb places a call into a conference. { verb : conference , name : test , beep : true, startConferenceOnEnter : false, waitHook : /confWait , enterHook : /confEnter }, You can use the following attributes in the conference command: option description required actionHook A webhook to call when the conference ends no beep if true, play a beep tone to the conference when caller enters (default: false) no endConferenceOnExit if true, end the conference when this caller hangs up (default: false) no enterHook A webhook to retrieve something to play or say to the caller just before they are put into a conference after waiting for it to start no maxParticipants maximum number of participants that will be allowed in the conference no name name of the conference yes startConferenceOnEnter if true, start the conference only when this caller enters (default: true) no statusHook A webhook to call with conference status events no statusEvents An array of events for which the statusHook should be called to. See below for details. no waitHook A webhook to retrieve commands to play or say while the caller is waiting for the conference to start no Note: A conference bridge belongs to an Account (the Account that is associated with the Application that created the conference), and only calls generated from Applications under that Account can join that conference. The conference name property should be unique within an Account for different conference bridges; however, the same name can be used by different Accounts and each will refer to different conference bridges on the media servers. Conference events: 'start': the conference has started 'end': the conference has ended 'join': a participant has joined the conference 'leave': a participant has left the conference 'start-talking': a participant started speaking 'end-talking': a participant stopped talking Conference status webhooks will contain the following additional parameters: conferenceSid: a unique identifier for the conference friendlyName: the name of the conference as specified in the application event: the conference event being reported (e.g. \"join\") time: the time of the event in ISO format (e.g. \"2020-04-27T13:44:17.336Z\") members: the current number of members in the conference duration: the current length of the conference in seconds dequeue The dequeue verb removes the a call from the front of a specified queue and bridges that call to the current caller. { verb : dequeue , name : support , beep : true, timeout : 60 } You can use the following options in the dequeue command: option description required name name of the queue yes actionHook A webhook invoke when call ends. If no webhook is provided, execution will continue with the next verb in the current application. See below for specified request parameters. no beep if true, play a beep tone to this caller only just prior to connecting the queued call; this provides an auditory cue that the call is now connected no confirmHook A webhook for an application to run on the callee's end before the call is bridged. This will allow the application to play an informative message to a caller as they leave the queue (e.g. \"your call may be recorded\") no timeout number of seconds to wait on an empty queue before returning (default: wait forever) no The actionHook webhook will contain the following additional parameters: dequeueResult : the completion reason: 'hangup' - the bridged call was abandoned while listening to the confirmHook message 'complete' - the call was successfully bridged and ended with a caller hangup 'timeout' - no call appeared in the named queue during the timeout interval 'error' - a system error of some kind occurred dial The dial verb is used to create a new call by dialing out to a number, a registered sip user, or sip endpoint. { verb : dial , actionHook : /outdial , callerId : +16173331212 , answerOnBridge : true, dtmfCapture : [ *2 , *3 ], dtmfHook : { url : /dtmf , method : GET }, target : [ { type : phone , number : +15083084809 }, { type : sip , sipUri : sip:1617333456@sip.trunk1.com , auth : { user : foo , password : bar } }, { type : user , name : spike@sip.example.com } ] } As the example above illustrates, when you execute the 'dial' command you are making one or more outbound call attempts in an effort to create one new call, which can be bridged to a parent call. The target property specifies an array of call destinations (aka endpoints ) that will be attempted simultaneously. If multiple endpoints are specified in the target array, all targets are outdialed at the same time (e.g., \"simring\", or \"blast outdial\" as some folks call it) and the call will be connected to the first endpoint that answers the call and, optionally, completes a call screening application as specified in the url property. There are several types of endpoints: a telephone phone number, a sip endpoint, identified by a sip uri (and possibly authentication parameters), a conference, a webrtc or sip client that has registered directly with your application, or Microsoft Teams user You can use the following attributes in the dial command: option description required actionHook webhook to invoke when the call ends. no answerOnBridge If set to true, the inbound call will ring until the number that was dialed answers the call, and at that point a 200 OK will be sent on the inbound leg. If false, the inbound call will be answered immediately as the outbound call is placed. Defaults to false. no callerId The inbound caller's phone number, which is displayed to the number that was dialed. The caller ID must be a valid E.164 number. Defaults to caller id on inbound call. no confirmHook webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This allows the caller to provide information to the dialed number, giving them the opportunity to decline the call, before they answer the call. Note that if you want to run different applications on specific destinations, you can specify the 'url' property on the nested target object. no dialMusic url that specifies a .wav or .mp3 audio file of custom audio or ringback to play to the caller while the outbound call is ringing. no dtmfCapture an array of strings that represent dtmf sequence which, when detected, will trigger a mid-call notification to the application via the configured dtmfHook no dtmfHook a webhook to call when a dtmfCapture entry is matched. This is a notification only -- no response is expected, and any desired actions must be carried out via the REST updateCall API. no headers an object containing arbitrary sip headers to apply to the outbound call attempt(s) no listen a nested listen action, which will cause audio from the call to be streamed to a remote server over a websocket connection no target array of to 10 destinations to simultaneously dial. The first person (or entity) to answer the call will be connected to the caller and the rest of the called numbers will be hung up. yes timeLimit max length of call in seconds no timeout ring no answer timeout, in seconds. Defaults to 60. no transcribe a nested transcribe action, which will cause the call to be transcribed no target types PSTN number option description required type must be \"phone\" yes confirmHook A webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This will override the confirmHook property set on the parent dial verb, if any. no number a telephone numnber in E.164 number yes sip endpoint option description required type must be \"sip\" yes confirmHook A webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This will override the confirmHook property set on the parent dial verb, if any. no sipUri sip uri to send call to yes auth authentication credentials no auth.user sip username no auth.password sip password no Using this approach, it is possible to send calls out a sip trunk. If the sip trunking provider enforces username/password authentication, supply the credentials in the auth property. a registered webrtc or sip user option description required type must be \"user\" yes confirmHook A webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This will override the confirmHook property set on the parent dial verb, if any. no name registered sip user, including domain (e.g. \"joeb@sip.jambonz.org\") yes Microsoft Teams user If Microsoft Teams integration has been configured, you can dial out to Teams users. option description required type must be \"teams\" yes tenant Microsoft Teams customer tenant domain name. Will default to the Microsoft Teams tenant associated with the account of the calling party. no number the phone number that has been mapped to the teams user by the Microsoft Teams administrator yes voicemail if true, dial directly into user's voicemail to leave a message no The confirmHook property that can be optionally specified as part of the target types (with the exception of the park type) is a web callback that will be invoked when the outdial call is answered. That callback should return an application that will run on the outbound call before bridging it to the inbound call. If the application completes with the outbound call still in a stable/connected state, then the two calls will be bridged together. This allows you to easily implement call screening applications (e.g. \"You have a call from so-and-so. Press 1 to decline\"). dialogflow The dialogflow verb is used to connect a call to a dialogflow bot. { verb : dialogflow , project : ai-in-rtc-drachtio-tsjjpn , lang : en-US , credentials: {\\ type\\ : \\ service_account\\ ,\\ project_id\\ : \\ ai-in-rtc-drachtio...} , welcomeEvent : welcome , eventHook : /dialogflow-event , actionHook : /dialogflow-action } You can use the following options in the dialogflow verb: option description required project the Google dialogflow project id yes lang language to use for speech recognition yes credentials the service account key in JSON string form that is used to authenticate to dialogflow yes welcomeEvent An event to send to dialogflow when first connecting; e.g. to trigger a welcome prompt no welcomeEventParams An object containing parameters to send with the welcome event no noInputTimeout Number of seconds of no speech detected after which to reprompt no noInputEvent Name of dialogflow event to send in query when no input timeout expires no passDtmfAsTextInput If true, pass user dtmf entries as text inputs to the dialogflow bot no thinkingMusic A url to a .wav or .mp3 file to play as filler music while the dialogflow back-end is executing no actionHook A webhook invoke when operation completes. See below for specified request parameters. no eventHook A webhook to invoke when a dialogflow event occurs, such as an intent being detected or a speech transcription being returned. The response to the event hook may contain a new jambonz application to execute no The actionHook webhook will contain the following additional parameters: dialogflowResult : the completion reason: redirect - a new application was returned from an event webhook completed - an intent with end iteraction set to true was received from dialogflow The eventHook webhook will contain two parameters: event and data . The event parameter identifies the specific event and the data parameter is an object containng event data associated with the event. The following events are supported: intent : dialogflow detected an intent transcription : a speech transcription was returned from dialogflow dmtf : a dtmf key was pressed by the caller start-play : an audio segment returned from dialogflow started to play stop-play : an audio segment returned from dialogflow completing playing no-input : the no input timer elapsed with no input detected from the caller Please refer to this tutorial for a detailed example. call transfer Call transfer from a dialogflow bot is achieved by responding to an eventHook with event intent by returning a new jambonz application containing a dial verb. Of course, this should only be done if the intent is signaling a request for a call transfer. Indicating a desire to transfer the call to a live agent can be done in a couple of different ways in the dialogflow editor: By adding a Dialogflow Phone Gateway Response to the intent, with a Transfer Call action. By adding a custom payload in a response to the intent, with arbitrary JSON content that you define and which should include the telephone number (or registered user, or sip endpoint) to transfer to. Note: option 1 only works when transferring to a US number, because the dialogflow editor only accepts US destinations. To transfer to non-US destinations, use option 2. In either case, your application is responsible for having an eventHook that parses the intent (found in the data property of the webhook content) in order to check if call transfer is being requested, and if so responding with a new jambonz application. For instance, when the Dialogflow Phone Gateway Response is used (option 1 above), the code snippet below shows where to find the transfer number in the intent data provided in the eventHook. const evt = req.body; if (evt.event === 'intent') { const qo = evt.data.query_result; const transfer = qo.fulfillment_messages.find((fm) = { return fm.platform === 'TELEPHONY' fm.telephony_transfer_call; }); if (transfer) { // a transfer has been requested // transfer.telephony_transfer_call.phone_number has the phone number to transfer to } } Please refer to this tutorial for a detailed example. enqueue The enqueue command is used to place a caller in a queue. { verb : enqueue , name : support , actionHook : /queue-action , waitHook : /queue-wait } You can use the following options in the enqueue command: option description required name name of the queue yes actionHook A webhook invoke when operation completes. If a call is dequeued through the leave verb, the webook is immediately invoked. If the call has been bridged to another party via the dequeue verb, then the webhook is invoked after both parties have disconnected. If no webhook is provided, execution will continue with the next verb in the current application. See below for specified request parameters. no waitHook A webhook to invoke while the caller is in queue. The only allowed verbs in the application returned from this webhook are say , play , pause , and leave , See below for additional request parameters no The actionHook webhook will contain the following additional parameters: queueSid : the unique identifier for the queue queueResult : the completion reason: 'hangup' - the call was abandoned while in queue 'leave' - a leave verb caused the call to exit the queue 'bridged' - a dequeue verb caused the call to be bridged to another call 'error' - a system error of some kind occurred queueTime - the number of seconds the call spent in queue The waitHook webhook will contain the following additional parameters: queueSid : the unique identifier for the queue queuePosition : the current zero-based position in the queue queueTime : the current number of seconds the call has spent in queue queueSize : the current number of calls in the queue gather The gather command is used to collect dtmf or speech input. { verb : gather , actionHook : http://example.com/collect , input : [ digits , speech ], finishOnKey : # , numDigits : 5, timeout : 8, recognizer : { vendor : google , language : en-US }, say : { text : To speak to Sales press 1. To speak to customer support press 2. , synthesizer : { vendor : google , language : en-US } } } You can use the following options in the gather command: option description required actionHook webhook POST to invoke with the collected digits or speech. The payload will include a 'speech' or 'dtmf' property along with the standard attributes. See below for more detail. yes finishOnKey dmtf key that signals the end of input no input array, specifying allowed types of input: ['digits'], ['speech'], or ['digits', 'speech']. Default: ['digits'] no numDigits number of dtmf digits expected to gather no partialResultHook webhook to send interim transcription results to. Partial transcriptions are only generated if this property is set. no play nested play command that can be used to prompt the user no recognizer.hints array of words or phrases to assist speech detection no recognizer.language language code to use for speech detection. Defaults to the application level setting, or 'en-US' if not set no recognizer.profanityFilter if true, filter profanity from speech transcription. Default: no no recognizer.vendor speech vendor to use (currently only google supported) no say nested say command that can be used to prompt the user no timeout The number of seconds of silence or inaction that denote the end of caller input. The timeout timer will begin after any nested play or say command completes. Defaults to 5 no In the case of speech input, the actionHook payload will include a speech object with the response from google speech: speech : { stability : 0, is_final : true, alternatives : [{ confidence : 0.858155, transcript : sales please }] } In the case of digits input, the payload will simple include a digits property indicating the dtmf keys pressed: digits : 0276 Note : an HTTP POST will be used for both the action and the partialResultCallback since the body may need to contain nested JSON objects for speech details. Note: the partialResultCallback web callback should not return content; any returned content will be discarded. hangup The hangup command terminates the call and ends the application. { verb : hangup , headers : { X-Reason : maximum call duration exceeded } } You can use the following options in the hangup action: option description required headers an object containing SIP headers to include in the BYE request no leave The leave verb transfers a call out of a queue. The call then returns to the flow of execution following the enqueue verb that parked the call, or the document returned by that verbs actionHook property, if provided. { verb : leave } There are no options for the leave verb. listen jambonz does not have a 'record' verb. This is by design, for data privacy reasons. Recordings can contain sensitive and confidential information, and such data is never stored at rest in the jambonz core. Instead, jambonz provides the listen verb, where an audio stream(s) can be forked and sent in real-time to a customer application for processing. The listen verb can also be nested in a dial verb, which allows the audio for a call between two parties to be sent to a remote websocket server. To utilize the listen verb, the customer must implement a websocket server to receive and process the audio. The endpoint should be prepared to accept websocket connections with a subprotocol name of 'audio.jambonz.org'. The listen verb includes a url property which is the url of the remote websocket server to send the audio to. The url may be an absolute or relative URL. HTTP Basic Authentication can optionally be used to protect the websocket endpoint by using the wsAuth property. The format of the audio data sent over the websocket is 16-bit PCM encoding, with a user-specified sample rate. The audio is sent in binary frames over the websocket connection. Additionally, one text frame is sent immediately after the websocket connection is established. This text frame contains a JSON string with all of the call attributes normally sent on an HTTP request (e.g. callSid, etc), plus sampleRate and mixType properties describing the audio sample rate and stream(s). Additional metadata can also be added to this payload using the metadata property as described in the table below. Once the intial text frame containing the metadata has been sent, the remote side should expect to receive only binary frames, containing audio. The remote side is not expected to send any data back over the websocket. { verb : listen , url : wss://myrecorder.example.com/calls/271314e6-b463-4980-b007-80defc181058:4433 , mixType : stereo } You can use the following options in the listen action: option description required actionHook webhook to invoke when listen operation ends. The information will include the duration of the audio stream, and also a 'digits' property if the recording was terminated by a dtmf key. yes finishOnKey The set of digits that can end the listen action no maxLength the maximum length of the listened audio stream, in secs no metadata arbitrary data to add to the JSON payload sent to the remote server when websocket connection is first connected no mixType \"mono\" (send single channel), \"stereo\" (send dual channel of both calls in a bridge), or \"mixed\" (send audio from both calls in a bridge in a single mixed audio stream) Default: mono no playBeep true, false whether to play a beep at the start of the listen operation. Default: false no sampleRate sample rate of audio to send (allowable values: 8000, 16000, 24000, 48000, or 64000). Default: 8000 no timeout the number of seconds of silence that terminates the listen operation. no transcribe a nested transcribe verb no url url of remote server to connect to yes wsAuth.username HTTP basic auth username to use on websocket connection no wsAuth.password HTTP basic auth password to use on websocket connection no pause The pause command waits silently for a specified number of seconds. { verb : pause , length : 3 } You can use the following options in the pause action: option description required length number of seconds to wait before continuing the app yes play The play command is used to stream recorded audio to a call. { verb : play , url : https://example.com/example.mp3 } You can use the following options in the play action: option description required url a single url or array of urls (will play in sequence) to a wav or mp3 file yes loop number of times to play the url(s) no (default: 1) earlyMedia if true and the call has not yet been answered, play the audio without answering call. Defaults to false no redirect The redirect action is used to transfer control to another JSON document taht is retrieved from the specified url. All actions after redirect are unreachable and ignored. { verb : redirect , actionHook : /connectToSales , } You can use the following options in the redirect action: option description required actionHook URL of webhook to retrieve new application from. yes say The say command is used to send synthesized speech to the remote party. The text provided may be either plain text or may use SSML tags. { verb : say , text : hi there! , synthesizer : { vendor : google , language : en-US } } You can use the following options in the say action: option description required text text to speak; may contain SSML tags yes synthesizer.vendor speech vendor to use: google or aws (polly is also an alias for aws) no synthesizer.language language code to use. yes synthesizer.gender (google only) MALE, FEMALE, or NEUTRAL. no synthesizer.voice voice to use. Note that the voice list differs whether you are using aws or google. Defaults to application setting, if provided. no loop the number of times a text is to be repeated; 0 means repeat forever. Defaults to 1. no earlyMedia if true and the call has not yet been answered, play the audio without answering call. Defaults to false no sip:decline The sip:decline action is used to reject an incoming call with a specific status and, optionally, a reason and SIP headers to include on the response. This action must be the first and only action returned in the JSON payload for an incoming call. The sip:decline action is a non-blocking action and the session ends immediately after the action is executed. { verb : sip:decline , status : 480, reason : Gone Fishing , headers : { Retry-After : 1800 } } You can use the following options in the sip:decline action: option description required status a valid SIP status code in the range 4XX - 6XX yes reason a brief description no (default: the well-known SIP reasons associated with the specified status code headers SIP headers to include in the response no tag The tag verb is used to add properties to the standard call attributes that jambonz includes on every action or call status HTTP POST request. Note: because of the possible richness of the data, only subsequent POST requests will include this data. It will not be included in HTTP GET requests. The purpose is to simplify applications by eliminating the need to store state information if it can simply be echoed back to the application on each HTTP request for the call. For example, consider an application that wishes to apply some privacy settings on outdials based on attributes in the initial incoming call. The application could parse information from the SIP INVITE provided in the web callback when the call arrives, and rather than having to store that information for later use it could simply use the 'tag' verb to associate that information with the call. Later, when an action or call status triggers the need for the application to outdial it can simply access the information from the HTTP POST body, rather than having to retrieve it from the cache of some sort. Note that every time the tag verb is used, the collection of customer data is completely replaced with the new data provided. This information will be provided back in all action or status notifications if POST method is used. It will appear in property named 'customerData' in the JSON payload. { verb : tag , data { foo : bar , counter : 100, list : [1, 2, three ] } } After the above 'tag' verb has executed, web callbacks using POST would have a payload similar to this: { callSid : df09e8d4-7ffd-492b-94d9-51a60318552c , direction : inbound , from : +15083084809 , to : +15083728299 , callId : f0414693-bdb6-1238-6185-06d91d68c9b0 , sipStatus : 200, callStatus : in-progress , callerId : f0414693-bdb6-1238-6185-06d91d68c9b0 , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , originatingSipIp : 54.172.60.1:5060 , originatingSipTrunkName : twilio , customerData : { foo : bar , counter : 100, list : [1, 2, three ] } } You can use the following options in the tag command: option description required data a JSON object containing values to be saved and included in future action or call status notifications (HTTP POST only) for this call yes transcribe The transcribe verb is used to send real time transcriptions of speech to a web callback. The transcribe command is only allowed as a nested verb within a dial or listen verb. Using transcribe in a dial command allows a long-running transcription of a phone call to be made, while nesting within a listen verb allows transcriptions of recorded messages (e.g. voicemail). { verb : transcribe , transcriptionHook : http://example.com/transcribe , recognizer : { vendor : google , language : en-US , interim : true } } You can use the following options in the transcribe command: option description required recognizer.dualChannel if true, transcribe the parent call as well as the child call no recognizer.interim if true interim transcriptions are sent no (default: false) recognizer.language language to use for speech transcription yes recognizer.profanityFilter if true, filter profanity from speech transcription. Default: no no recognizer.vendor speech vendor to use (currently only google supported) no transcriptionHook webhook to call when a transcription is received. Due to the richness of information in the transcription an HTTP POST will always be sent. yes Note : the dualChannel property is not currently implemented. Example messages An example JSON payload for a webhook for an incoming call using a POST method. There's a lot of detail here, because when you specify to receive a POST you are getting the full SIP INVITE. { direction : inbound , callSid : 1fe62f7c-ebb9-4b96-b75b-7d04ff2b195d , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083084809 , to : +15083728299 , callerName : +15083084809 , callId : 252a93d3-bdb2-1238-6185-06d91d68c9b0 , sipStatus : 100, callStatus : trying , originatingSipIp : 54.172.60.2:5060 , originatingSipTrunkName : twilio , sip : { headers : { via : SIP/2.0/UDP 3.10.235.99;rport=5060;branch=z9hG4bKgeBy6Fg863Z8N;received=172.31.3.33 , max-forwards : 70 , from : sip:+15083084809@3.10.235.99:5060 ;tag=vQXQ3g5papXpF , to : sip:+15083728299@172.31.3.33:5070 , call-id : 252a93d3-bdb2-1238-6185-06d91d68c9b0 , cseq : 15623387 INVITE , contact : sip:+15083084809@3.10.235.99:5060 , user-agent : Twilio Gateway , allow : INVITE, ACK, CANCEL, BYE, REFER, NOTIFY, OPTIONS , content-type : application/sdp , content-length : 264 , X-CID : f9221ea5e66a1d1f10a0b556933dc0c2@0.0.0.0 , X-Forwarded-For : 54.172.60.2:5060 , X-Originating-Carrier : twilio , Diversion : sip:+15083728299@public-vip.us1.twilio.com ;reason=unconditional }, body : v=0\\r\\no=root 1999455157 1999455157 IN IP4 3.10.235.99\\r\\ns=Twilio Media Gateway\\r\\nc=IN IP4 3.10.235.99\\r\\nt=0 0\\r\\nm=audio 49764 RTP/AVP 0 101\\r\\na=maxptime:150\\r\\na=rtpmap:0 PCMU/8000\\r\\na=rtpmap:101 telephone-event/8000\\r\\na=fmtp:101 0-16\\r\\na=sendrecv\\r\\na=rtcp:49765\\r\\na=ptime:20\\r\\n , payload : [{ type : application/sdp , content : v=0\\r\\no=root 1999455157 1999455157 IN IP4 3.10.235.99\\r\\ns=Twilio Media Gateway\\r\\nc=IN IP4 3.10.235.99\\r\\nt=0 0\\r\\nm=audio 49764 RTP/AVP 0 101\\r\\na=maxptime:150\\r\\na=rtpmap:0 PCMU/8000\\r\\na=rtpmap:101 telephone-event/8000\\r\\na=fmtp:101 0-16\\r\\na=sendrecv\\r\\na=rtcp:49765\\r\\na=ptime:20\\r\\n }], method : INVITE , version : 2.0 , uri : sip:+15083728299@172.31.3.33:5070 , raw : INVITE sip:+15083728299@172.31.3.33:5070 SIP/2.0\\r\\nVia: SIP/2.0/UDP 3.10.235.99;rport=5060;branch=z9hG4bKgeBy6Fg863Z8N;received=172.31.3.33\\r\\nMax-Forwards: 70\\r\\nFrom: sip:+15083084809@3.10.235.99:5060 ;tag=vQXQ3g5papXpF\\r\\nTo: sip:+15083728299@172.31.3.33:5070 \\r\\nCall-ID: 252a93d3-bdb2-1238-6185-06d91d68c9b0\\r\\nCSeq: 15623387 INVITE\\r\\nContact: sip:+15083084809@3.10.235.99:5060 \\r\\nUser-Agent: Twilio Gateway\\r\\nAllow: INVITE, ACK, CANCEL, BYE, REFER, NOTIFY, OPTIONS\\r\\nContent-Type: application/sdp\\r\\nContent-Length: 264\\r\\nX-CID: f9221ea5e66a1d1f10a0b556933dc0c2@0.0.0.0\\r\\nX-Forwarded-For: 54.172.60.2:5060\\r\\nX-Originating-Carrier: twilio\\r\\nDiversion: sip:+15083728299@public-vip.us1.twilio.com ;reason=unconditional\\r\\nX-Twilio-AccountSid: AC58f23d38858ac262d6ee2e554b30c561\\r\\nX-Twilio-CallSid: CA708d85d118aacfcc794b730fa02bc40c\\r\\n\\r\\nv=0\\r\\no=root 1999455157 1999455157 IN IP4 3.10.235.99\\r\\ns=Twilio Media Gateway\\r\\nc=IN IP4 3.10.235.99\\r\\nt=0 0\\r\\nm=audio 49764 RTP/AVP 0 101\\r\\na=maxptime:150\\r\\na=rtpmap:0 PCMU/8000\\r\\na=rtpmap:101 telephone-event/8000\\r\\na=fmtp:101 0-16\\r\\na=sendrecv\\r\\na=rtcp:49765\\r\\na=ptime:20\\r\\n } } An example JSON payload for a call status webhook for an incoming call using a POST method: { direction : inbound , callSid : 1fe62f7c-ebb9-4b96-b75b-7d04ff2b195d , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083084809 , to : +15083728299 , callerName : +15083084809 , callId : 252a93d3-bdb2-1238-6185-06d91d68c9b0 , sipStatus : 200, callStatus : in-progress , originatingSipIp : 54.172.60.2:5060 , originatingSipTrunkName : twilio } An example JSON payload for a call status webhook for an outbound call using a POST method: { direction : outbound , callSid : ddd6d4b2-ba3f-42fb-9845-8abdac047097 , parentCallSid : 1fe62f7c-ebb9-4b96-b75b-7d04ff2b195d , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083084809 , to : +15084901000 , callerName : +15083084809 , callId : a5726393-bdaf-1238-9483-06d91d68c9b0 , callStatus : in-progress , sipStatus : 200 }","title":"jambonz Webhooks"},{"location":"jambonz/#overview","text":"jambonz is a specification for issuing call control commands via JSON payloads over HTTP connections. These messages are sent from your application in response to web callbacks from a jambonz call control server, and they provide jambonz with your instructions on how to handle a call. When an incoming call is received by the platform, jambonz makes an HTTP request to the URL endpoint that is configured for that called number. Outbound calls that are initiated by the REST API are controlled in a similar way -- when invoking the REST API to launch a call, you provide a web callback url and in your response to the subsequent HTTP GET or POST to that url you then return a JSON payload describing the application that should govern the outbound call.","title":"Overview"},{"location":"jambonz/#basic-json-message-structure","text":"The JSON payload (aka the \"application\") that you provide in response to a callback must be an array of objects, with each object describing a task that the platform shall perform. These tasks are executed sequentially in the order they appear in the array. Each task is identified by a verb (e.g. \"dial\", \"gather\", \"hangup\" etc) with associated detail and these verbs are described in more detail below. If the caller hangs up during the execution of an application for that call, the current task is allowed to complete and any remaining tasks in the application are ignored. Through additional callbacks that may be invoked during the execution of an application (typically as a result of those verbs which have an \"action\" property callback), the current application may be replaced with a new JSON application document. In such a case, the new document begins executing, and any remaining tasks in the original document are discarded. Each task object in the JSON array must include a \"verb\" property that describes the action to take. Any additional information that the task needs to operate are provided as properties as well, e.g.: { verb : say , text : Hi there! Please leave a message at the tone and we will get back to you shortly. , synthesizer : { vendor : google , language : en-US , gender : FEMALE } } Some verbs allow other verbs to be nested; e.g. \"gather\" can have a nested \"say\" command in order to play a prompt and collect a response in one command: { verb : gather , actionHook : /gatherCardNumber , input : [ speech , dtmf ], timeout : 16, numDigits : 6, recognizer : { vendor : google , language : en-US }, say : { text : Please say or enter your six digit card number now , synthesizer : { vendor : google , language : en-US , gender : FEMALE } } } Altogether then, a simple example application which provides the basics of a voicemail application with transcription would look like this: [ { verb : say , text : Hi there! Please leave a message at the tone and we will get back to you shortly. Thanks, and have a great day! }, { verb : listen , actionHook : http://example.com/voicemail , url : http://ws.example.com , finishOnKey : # , metadata : { topic : voicemail }, mixType : mono , playBeep : true, timeout : 20, transcribe : { transcriptionHook : /transcription } }, { verb : say , text : Thanks for your message. We'll get back to you } ] Hey, did you see what we did there? It's a voicemail application, but where is the recording url? How do you retrieve the recording after the call? There is none, and you don't. Let's rethink this: Instead of making a recording -- which exposes your customer's PII since we now have to store sensitive data at rest in the platform -- how's about we instead send you a real-time audio stream over a secure websocket connection while the call is proceeding. Annotate it with any metadata you need for tracking on your end, and we'll send that along as well. Thus, you get the audio in real-time and we don't ever store your customer's sensitive data at rest. Bam. Done.","title":"Basic JSON message structure"},{"location":"jambonz/#http-connection-details","text":"Each HTTP request that jambonz makes to one of your callbacks will include (at least) the following information either as query arguments (in a GET request) or in the body of the response as a JSON payload (in a POST request): callSid: a unique identifier for the call, in a uuid format. applicationSid: a unique identifier for the jambonz application controlling this call accountSid: a unique identifier for the jambonz account associated with the application direction: the direction of the call, either 'inbound' or 'outbound' from: the calling party number to: the called party number callerId: the caller name, if known callStatus: current status of the call, see table below sipStatus: the most recent sip status code received or generated for the call Additionally, the request MAY include parentCallSid: the callSid of a parent call to this call, if this call is a child call And the initial webhook for a new incoming call will have: originatingSipTrunkName: name of the SIP trunk that originated the call to the platform originatingSipIp: the ip address and port of the sip gateway that originated the call Finally, if you specify to use a POST method for the initial webhook for an incoming call, the JSON payload in that POST will also contain the entire incoming SIP INVITE request details in a 'sip' property (this is not provided if a GET request is used). This can be useful if you need a detailed look at all of the SIP headers or the Session Description Protocol being offered. Note also that the information that jambonz sends you with each HTTP request can be augmented by your application by using the tag verb. You may optionally use HTTP Basic Authentication to protect your endpoints. call status value description trying a new incoming call has arrived or an outbound call has just been sent ringing a 180 Ringing response has been sent or received early-media an early media connection has been established prior to answering the call (183 Session Progress) in-progress call has been answered completed an answered call has ended failed a call attempt failed busy a call attempt failed because the called party returned a busy status no-answer a call attempt failed because it was not answered in time Refer to the Example messages section to see further details.","title":"HTTP connection details"},{"location":"jambonz/#initial-state-of-incoming-calls","text":"When the jambonz platform receives a new incoming call, it responds 100 Trying to the INVITE but does not automatically answer the call. It is up to your application to decide how to finally respond to the INVITE. You have some choices here. Your application can: answer the call, which connects the call to a media endpoint that can perform IVR functions on the call, outdial a new call, and bridge the two calls together (i.e use the dial verb), reject the call, with a specified SIP status code and reason, redirect the call (i.e. generating a SIP 302 response back to the caller), or establish an early media connection and play audio to the caller without answering the call. The last is interesting and worthy of further comment. The intent is to let you play audio to callers without necessarily answering the call. You signal this by including an \"earlyMedia\" property with a value of true in the application. When receiving this, the jambonz core will create an early media connection (183 Session Progress) if possible, as shown in the example below. Note: an early media connection will not be possible if the call has already been answered by an earlier verb in the application. In such a scenario, the earlyMedia property is ignored. [ { verb : say , earlyMedia : true, text : Please call back later, we are currently at lunch synthesizer : { vendor : aws , language : en-US , voice : Amy }, { verb : sip:decline , status : 480, headers : { Retry-After : 1800 } } } ] The say, play, gather, listen, and transcribe verbs all support the \"earlyMedia\" property. The dial verb supports a similar feature of not answering the inbound call unless/until the dialed call is answered via the \"answerOnBridge\" property.","title":"Initial state of incoming calls"},{"location":"jambonz/#speech-integration","text":"The platform makes use of text-to-speech as well as real-time speech recognition. Both google and AWS/Polly are supported for text to speech. Currently only google is supported for speech to text. Synthesized audio is cached for up to 24 hours, so that if the same {text, language, voice} combination is requested more than once in that period it will be served from cache, reducing speech synthesis costs. A JSON service key file containing GCP credentials for cloud speech services must be downloaded and installed on the jambonz feature servers to enable tts and speech recognition for google. For AWS/Polly, the environment variables AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_REGION must be provided in the server environments where the jambonz-feature-server application is running. As part of the definition of an application, you can set defaults for the language and voice to use for speech synthesis as well as the language to use for speech recognition. These can then be overridden by verbs in the application, by using the 'synthesizer' and 'recognizer' properties./","title":"Speech integration"},{"location":"jambonz/#webhooks","text":"Many of the verbs specify a webhook that will be called when the verb completes, or has some information to deliver to your application. These verbs contain a property that allow you to configure that webhook. By convention, the property name will always end in \"Hook\"; e.g \"actionHook\", \"dtmfHook\", and so on. You can either specify the webhook as a simple string specifying a url: actionHook : https://my.appserver.com/results or a relative url actionHook : /results In the latter case, the base url of the application will be applied. Alternatively, you can provide an object containing a url (required) and optional method and basic authentication parameters, e.g.: actionHook : { url : https://my.appserver.com/results , method : GET , username : foo , password : bar } In the verb descriptions below, whenever we indicate a property is a webhook we are referring to this syntax.","title":"Webhooks"},{"location":"jambonz/#supported-verbs","text":"Each of the supported verbs are described below.","title":"Supported Verbs"},{"location":"jambonz/#conference","text":"The conference verb places a call into a conference. { verb : conference , name : test , beep : true, startConferenceOnEnter : false, waitHook : /confWait , enterHook : /confEnter }, You can use the following attributes in the conference command: option description required actionHook A webhook to call when the conference ends no beep if true, play a beep tone to the conference when caller enters (default: false) no endConferenceOnExit if true, end the conference when this caller hangs up (default: false) no enterHook A webhook to retrieve something to play or say to the caller just before they are put into a conference after waiting for it to start no maxParticipants maximum number of participants that will be allowed in the conference no name name of the conference yes startConferenceOnEnter if true, start the conference only when this caller enters (default: true) no statusHook A webhook to call with conference status events no statusEvents An array of events for which the statusHook should be called to. See below for details. no waitHook A webhook to retrieve commands to play or say while the caller is waiting for the conference to start no Note: A conference bridge belongs to an Account (the Account that is associated with the Application that created the conference), and only calls generated from Applications under that Account can join that conference. The conference name property should be unique within an Account for different conference bridges; however, the same name can be used by different Accounts and each will refer to different conference bridges on the media servers. Conference events: 'start': the conference has started 'end': the conference has ended 'join': a participant has joined the conference 'leave': a participant has left the conference 'start-talking': a participant started speaking 'end-talking': a participant stopped talking Conference status webhooks will contain the following additional parameters: conferenceSid: a unique identifier for the conference friendlyName: the name of the conference as specified in the application event: the conference event being reported (e.g. \"join\") time: the time of the event in ISO format (e.g. \"2020-04-27T13:44:17.336Z\") members: the current number of members in the conference duration: the current length of the conference in seconds","title":"conference"},{"location":"jambonz/#dequeue","text":"The dequeue verb removes the a call from the front of a specified queue and bridges that call to the current caller. { verb : dequeue , name : support , beep : true, timeout : 60 } You can use the following options in the dequeue command: option description required name name of the queue yes actionHook A webhook invoke when call ends. If no webhook is provided, execution will continue with the next verb in the current application. See below for specified request parameters. no beep if true, play a beep tone to this caller only just prior to connecting the queued call; this provides an auditory cue that the call is now connected no confirmHook A webhook for an application to run on the callee's end before the call is bridged. This will allow the application to play an informative message to a caller as they leave the queue (e.g. \"your call may be recorded\") no timeout number of seconds to wait on an empty queue before returning (default: wait forever) no The actionHook webhook will contain the following additional parameters: dequeueResult : the completion reason: 'hangup' - the bridged call was abandoned while listening to the confirmHook message 'complete' - the call was successfully bridged and ended with a caller hangup 'timeout' - no call appeared in the named queue during the timeout interval 'error' - a system error of some kind occurred","title":"dequeue"},{"location":"jambonz/#dial","text":"The dial verb is used to create a new call by dialing out to a number, a registered sip user, or sip endpoint. { verb : dial , actionHook : /outdial , callerId : +16173331212 , answerOnBridge : true, dtmfCapture : [ *2 , *3 ], dtmfHook : { url : /dtmf , method : GET }, target : [ { type : phone , number : +15083084809 }, { type : sip , sipUri : sip:1617333456@sip.trunk1.com , auth : { user : foo , password : bar } }, { type : user , name : spike@sip.example.com } ] } As the example above illustrates, when you execute the 'dial' command you are making one or more outbound call attempts in an effort to create one new call, which can be bridged to a parent call. The target property specifies an array of call destinations (aka endpoints ) that will be attempted simultaneously. If multiple endpoints are specified in the target array, all targets are outdialed at the same time (e.g., \"simring\", or \"blast outdial\" as some folks call it) and the call will be connected to the first endpoint that answers the call and, optionally, completes a call screening application as specified in the url property. There are several types of endpoints: a telephone phone number, a sip endpoint, identified by a sip uri (and possibly authentication parameters), a conference, a webrtc or sip client that has registered directly with your application, or Microsoft Teams user You can use the following attributes in the dial command: option description required actionHook webhook to invoke when the call ends. no answerOnBridge If set to true, the inbound call will ring until the number that was dialed answers the call, and at that point a 200 OK will be sent on the inbound leg. If false, the inbound call will be answered immediately as the outbound call is placed. Defaults to false. no callerId The inbound caller's phone number, which is displayed to the number that was dialed. The caller ID must be a valid E.164 number. Defaults to caller id on inbound call. no confirmHook webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This allows the caller to provide information to the dialed number, giving them the opportunity to decline the call, before they answer the call. Note that if you want to run different applications on specific destinations, you can specify the 'url' property on the nested target object. no dialMusic url that specifies a .wav or .mp3 audio file of custom audio or ringback to play to the caller while the outbound call is ringing. no dtmfCapture an array of strings that represent dtmf sequence which, when detected, will trigger a mid-call notification to the application via the configured dtmfHook no dtmfHook a webhook to call when a dtmfCapture entry is matched. This is a notification only -- no response is expected, and any desired actions must be carried out via the REST updateCall API. no headers an object containing arbitrary sip headers to apply to the outbound call attempt(s) no listen a nested listen action, which will cause audio from the call to be streamed to a remote server over a websocket connection no target array of to 10 destinations to simultaneously dial. The first person (or entity) to answer the call will be connected to the caller and the rest of the called numbers will be hung up. yes timeLimit max length of call in seconds no timeout ring no answer timeout, in seconds. Defaults to 60. no transcribe a nested transcribe action, which will cause the call to be transcribed no","title":"dial"},{"location":"jambonz/#target-types","text":"PSTN number option description required type must be \"phone\" yes confirmHook A webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This will override the confirmHook property set on the parent dial verb, if any. no number a telephone numnber in E.164 number yes sip endpoint option description required type must be \"sip\" yes confirmHook A webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This will override the confirmHook property set on the parent dial verb, if any. no sipUri sip uri to send call to yes auth authentication credentials no auth.user sip username no auth.password sip password no Using this approach, it is possible to send calls out a sip trunk. If the sip trunking provider enforces username/password authentication, supply the credentials in the auth property. a registered webrtc or sip user option description required type must be \"user\" yes confirmHook A webhook for an application to run on the callee's end after the dialed number answers but before the call is connected. This will override the confirmHook property set on the parent dial verb, if any. no name registered sip user, including domain (e.g. \"joeb@sip.jambonz.org\") yes Microsoft Teams user If Microsoft Teams integration has been configured, you can dial out to Teams users. option description required type must be \"teams\" yes tenant Microsoft Teams customer tenant domain name. Will default to the Microsoft Teams tenant associated with the account of the calling party. no number the phone number that has been mapped to the teams user by the Microsoft Teams administrator yes voicemail if true, dial directly into user's voicemail to leave a message no The confirmHook property that can be optionally specified as part of the target types (with the exception of the park type) is a web callback that will be invoked when the outdial call is answered. That callback should return an application that will run on the outbound call before bridging it to the inbound call. If the application completes with the outbound call still in a stable/connected state, then the two calls will be bridged together. This allows you to easily implement call screening applications (e.g. \"You have a call from so-and-so. Press 1 to decline\").","title":"target types"},{"location":"jambonz/#dialogflow","text":"The dialogflow verb is used to connect a call to a dialogflow bot. { verb : dialogflow , project : ai-in-rtc-drachtio-tsjjpn , lang : en-US , credentials: {\\ type\\ : \\ service_account\\ ,\\ project_id\\ : \\ ai-in-rtc-drachtio...} , welcomeEvent : welcome , eventHook : /dialogflow-event , actionHook : /dialogflow-action } You can use the following options in the dialogflow verb: option description required project the Google dialogflow project id yes lang language to use for speech recognition yes credentials the service account key in JSON string form that is used to authenticate to dialogflow yes welcomeEvent An event to send to dialogflow when first connecting; e.g. to trigger a welcome prompt no welcomeEventParams An object containing parameters to send with the welcome event no noInputTimeout Number of seconds of no speech detected after which to reprompt no noInputEvent Name of dialogflow event to send in query when no input timeout expires no passDtmfAsTextInput If true, pass user dtmf entries as text inputs to the dialogflow bot no thinkingMusic A url to a .wav or .mp3 file to play as filler music while the dialogflow back-end is executing no actionHook A webhook invoke when operation completes. See below for specified request parameters. no eventHook A webhook to invoke when a dialogflow event occurs, such as an intent being detected or a speech transcription being returned. The response to the event hook may contain a new jambonz application to execute no The actionHook webhook will contain the following additional parameters: dialogflowResult : the completion reason: redirect - a new application was returned from an event webhook completed - an intent with end iteraction set to true was received from dialogflow The eventHook webhook will contain two parameters: event and data . The event parameter identifies the specific event and the data parameter is an object containng event data associated with the event. The following events are supported: intent : dialogflow detected an intent transcription : a speech transcription was returned from dialogflow dmtf : a dtmf key was pressed by the caller start-play : an audio segment returned from dialogflow started to play stop-play : an audio segment returned from dialogflow completing playing no-input : the no input timer elapsed with no input detected from the caller Please refer to this tutorial for a detailed example.","title":"dialogflow"},{"location":"jambonz/#call-transfer","text":"Call transfer from a dialogflow bot is achieved by responding to an eventHook with event intent by returning a new jambonz application containing a dial verb. Of course, this should only be done if the intent is signaling a request for a call transfer. Indicating a desire to transfer the call to a live agent can be done in a couple of different ways in the dialogflow editor: By adding a Dialogflow Phone Gateway Response to the intent, with a Transfer Call action. By adding a custom payload in a response to the intent, with arbitrary JSON content that you define and which should include the telephone number (or registered user, or sip endpoint) to transfer to. Note: option 1 only works when transferring to a US number, because the dialogflow editor only accepts US destinations. To transfer to non-US destinations, use option 2. In either case, your application is responsible for having an eventHook that parses the intent (found in the data property of the webhook content) in order to check if call transfer is being requested, and if so responding with a new jambonz application. For instance, when the Dialogflow Phone Gateway Response is used (option 1 above), the code snippet below shows where to find the transfer number in the intent data provided in the eventHook. const evt = req.body; if (evt.event === 'intent') { const qo = evt.data.query_result; const transfer = qo.fulfillment_messages.find((fm) = { return fm.platform === 'TELEPHONY' fm.telephony_transfer_call; }); if (transfer) { // a transfer has been requested // transfer.telephony_transfer_call.phone_number has the phone number to transfer to } } Please refer to this tutorial for a detailed example.","title":"call transfer"},{"location":"jambonz/#enqueue","text":"The enqueue command is used to place a caller in a queue. { verb : enqueue , name : support , actionHook : /queue-action , waitHook : /queue-wait } You can use the following options in the enqueue command: option description required name name of the queue yes actionHook A webhook invoke when operation completes. If a call is dequeued through the leave verb, the webook is immediately invoked. If the call has been bridged to another party via the dequeue verb, then the webhook is invoked after both parties have disconnected. If no webhook is provided, execution will continue with the next verb in the current application. See below for specified request parameters. no waitHook A webhook to invoke while the caller is in queue. The only allowed verbs in the application returned from this webhook are say , play , pause , and leave , See below for additional request parameters no The actionHook webhook will contain the following additional parameters: queueSid : the unique identifier for the queue queueResult : the completion reason: 'hangup' - the call was abandoned while in queue 'leave' - a leave verb caused the call to exit the queue 'bridged' - a dequeue verb caused the call to be bridged to another call 'error' - a system error of some kind occurred queueTime - the number of seconds the call spent in queue The waitHook webhook will contain the following additional parameters: queueSid : the unique identifier for the queue queuePosition : the current zero-based position in the queue queueTime : the current number of seconds the call has spent in queue queueSize : the current number of calls in the queue","title":"enqueue"},{"location":"jambonz/#gather","text":"The gather command is used to collect dtmf or speech input. { verb : gather , actionHook : http://example.com/collect , input : [ digits , speech ], finishOnKey : # , numDigits : 5, timeout : 8, recognizer : { vendor : google , language : en-US }, say : { text : To speak to Sales press 1. To speak to customer support press 2. , synthesizer : { vendor : google , language : en-US } } } You can use the following options in the gather command: option description required actionHook webhook POST to invoke with the collected digits or speech. The payload will include a 'speech' or 'dtmf' property along with the standard attributes. See below for more detail. yes finishOnKey dmtf key that signals the end of input no input array, specifying allowed types of input: ['digits'], ['speech'], or ['digits', 'speech']. Default: ['digits'] no numDigits number of dtmf digits expected to gather no partialResultHook webhook to send interim transcription results to. Partial transcriptions are only generated if this property is set. no play nested play command that can be used to prompt the user no recognizer.hints array of words or phrases to assist speech detection no recognizer.language language code to use for speech detection. Defaults to the application level setting, or 'en-US' if not set no recognizer.profanityFilter if true, filter profanity from speech transcription. Default: no no recognizer.vendor speech vendor to use (currently only google supported) no say nested say command that can be used to prompt the user no timeout The number of seconds of silence or inaction that denote the end of caller input. The timeout timer will begin after any nested play or say command completes. Defaults to 5 no In the case of speech input, the actionHook payload will include a speech object with the response from google speech: speech : { stability : 0, is_final : true, alternatives : [{ confidence : 0.858155, transcript : sales please }] } In the case of digits input, the payload will simple include a digits property indicating the dtmf keys pressed: digits : 0276 Note : an HTTP POST will be used for both the action and the partialResultCallback since the body may need to contain nested JSON objects for speech details. Note: the partialResultCallback web callback should not return content; any returned content will be discarded.","title":"gather"},{"location":"jambonz/#hangup","text":"The hangup command terminates the call and ends the application. { verb : hangup , headers : { X-Reason : maximum call duration exceeded } } You can use the following options in the hangup action: option description required headers an object containing SIP headers to include in the BYE request no","title":"hangup"},{"location":"jambonz/#leave","text":"The leave verb transfers a call out of a queue. The call then returns to the flow of execution following the enqueue verb that parked the call, or the document returned by that verbs actionHook property, if provided. { verb : leave } There are no options for the leave verb.","title":"leave"},{"location":"jambonz/#listen","text":"jambonz does not have a 'record' verb. This is by design, for data privacy reasons. Recordings can contain sensitive and confidential information, and such data is never stored at rest in the jambonz core. Instead, jambonz provides the listen verb, where an audio stream(s) can be forked and sent in real-time to a customer application for processing. The listen verb can also be nested in a dial verb, which allows the audio for a call between two parties to be sent to a remote websocket server. To utilize the listen verb, the customer must implement a websocket server to receive and process the audio. The endpoint should be prepared to accept websocket connections with a subprotocol name of 'audio.jambonz.org'. The listen verb includes a url property which is the url of the remote websocket server to send the audio to. The url may be an absolute or relative URL. HTTP Basic Authentication can optionally be used to protect the websocket endpoint by using the wsAuth property. The format of the audio data sent over the websocket is 16-bit PCM encoding, with a user-specified sample rate. The audio is sent in binary frames over the websocket connection. Additionally, one text frame is sent immediately after the websocket connection is established. This text frame contains a JSON string with all of the call attributes normally sent on an HTTP request (e.g. callSid, etc), plus sampleRate and mixType properties describing the audio sample rate and stream(s). Additional metadata can also be added to this payload using the metadata property as described in the table below. Once the intial text frame containing the metadata has been sent, the remote side should expect to receive only binary frames, containing audio. The remote side is not expected to send any data back over the websocket. { verb : listen , url : wss://myrecorder.example.com/calls/271314e6-b463-4980-b007-80defc181058:4433 , mixType : stereo } You can use the following options in the listen action: option description required actionHook webhook to invoke when listen operation ends. The information will include the duration of the audio stream, and also a 'digits' property if the recording was terminated by a dtmf key. yes finishOnKey The set of digits that can end the listen action no maxLength the maximum length of the listened audio stream, in secs no metadata arbitrary data to add to the JSON payload sent to the remote server when websocket connection is first connected no mixType \"mono\" (send single channel), \"stereo\" (send dual channel of both calls in a bridge), or \"mixed\" (send audio from both calls in a bridge in a single mixed audio stream) Default: mono no playBeep true, false whether to play a beep at the start of the listen operation. Default: false no sampleRate sample rate of audio to send (allowable values: 8000, 16000, 24000, 48000, or 64000). Default: 8000 no timeout the number of seconds of silence that terminates the listen operation. no transcribe a nested transcribe verb no url url of remote server to connect to yes wsAuth.username HTTP basic auth username to use on websocket connection no wsAuth.password HTTP basic auth password to use on websocket connection no","title":"listen"},{"location":"jambonz/#pause","text":"The pause command waits silently for a specified number of seconds. { verb : pause , length : 3 } You can use the following options in the pause action: option description required length number of seconds to wait before continuing the app yes","title":"pause"},{"location":"jambonz/#play","text":"The play command is used to stream recorded audio to a call. { verb : play , url : https://example.com/example.mp3 } You can use the following options in the play action: option description required url a single url or array of urls (will play in sequence) to a wav or mp3 file yes loop number of times to play the url(s) no (default: 1) earlyMedia if true and the call has not yet been answered, play the audio without answering call. Defaults to false no","title":"play"},{"location":"jambonz/#redirect","text":"The redirect action is used to transfer control to another JSON document taht is retrieved from the specified url. All actions after redirect are unreachable and ignored. { verb : redirect , actionHook : /connectToSales , } You can use the following options in the redirect action: option description required actionHook URL of webhook to retrieve new application from. yes","title":"redirect"},{"location":"jambonz/#say","text":"The say command is used to send synthesized speech to the remote party. The text provided may be either plain text or may use SSML tags. { verb : say , text : hi there! , synthesizer : { vendor : google , language : en-US } } You can use the following options in the say action: option description required text text to speak; may contain SSML tags yes synthesizer.vendor speech vendor to use: google or aws (polly is also an alias for aws) no synthesizer.language language code to use. yes synthesizer.gender (google only) MALE, FEMALE, or NEUTRAL. no synthesizer.voice voice to use. Note that the voice list differs whether you are using aws or google. Defaults to application setting, if provided. no loop the number of times a text is to be repeated; 0 means repeat forever. Defaults to 1. no earlyMedia if true and the call has not yet been answered, play the audio without answering call. Defaults to false no","title":"say"},{"location":"jambonz/#sipdecline","text":"The sip:decline action is used to reject an incoming call with a specific status and, optionally, a reason and SIP headers to include on the response. This action must be the first and only action returned in the JSON payload for an incoming call. The sip:decline action is a non-blocking action and the session ends immediately after the action is executed. { verb : sip:decline , status : 480, reason : Gone Fishing , headers : { Retry-After : 1800 } } You can use the following options in the sip:decline action: option description required status a valid SIP status code in the range 4XX - 6XX yes reason a brief description no (default: the well-known SIP reasons associated with the specified status code headers SIP headers to include in the response no","title":"sip:decline"},{"location":"jambonz/#tag","text":"The tag verb is used to add properties to the standard call attributes that jambonz includes on every action or call status HTTP POST request. Note: because of the possible richness of the data, only subsequent POST requests will include this data. It will not be included in HTTP GET requests. The purpose is to simplify applications by eliminating the need to store state information if it can simply be echoed back to the application on each HTTP request for the call. For example, consider an application that wishes to apply some privacy settings on outdials based on attributes in the initial incoming call. The application could parse information from the SIP INVITE provided in the web callback when the call arrives, and rather than having to store that information for later use it could simply use the 'tag' verb to associate that information with the call. Later, when an action or call status triggers the need for the application to outdial it can simply access the information from the HTTP POST body, rather than having to retrieve it from the cache of some sort. Note that every time the tag verb is used, the collection of customer data is completely replaced with the new data provided. This information will be provided back in all action or status notifications if POST method is used. It will appear in property named 'customerData' in the JSON payload. { verb : tag , data { foo : bar , counter : 100, list : [1, 2, three ] } } After the above 'tag' verb has executed, web callbacks using POST would have a payload similar to this: { callSid : df09e8d4-7ffd-492b-94d9-51a60318552c , direction : inbound , from : +15083084809 , to : +15083728299 , callId : f0414693-bdb6-1238-6185-06d91d68c9b0 , sipStatus : 200, callStatus : in-progress , callerId : f0414693-bdb6-1238-6185-06d91d68c9b0 , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , originatingSipIp : 54.172.60.1:5060 , originatingSipTrunkName : twilio , customerData : { foo : bar , counter : 100, list : [1, 2, three ] } } You can use the following options in the tag command: option description required data a JSON object containing values to be saved and included in future action or call status notifications (HTTP POST only) for this call yes","title":"tag"},{"location":"jambonz/#transcribe","text":"The transcribe verb is used to send real time transcriptions of speech to a web callback. The transcribe command is only allowed as a nested verb within a dial or listen verb. Using transcribe in a dial command allows a long-running transcription of a phone call to be made, while nesting within a listen verb allows transcriptions of recorded messages (e.g. voicemail). { verb : transcribe , transcriptionHook : http://example.com/transcribe , recognizer : { vendor : google , language : en-US , interim : true } } You can use the following options in the transcribe command: option description required recognizer.dualChannel if true, transcribe the parent call as well as the child call no recognizer.interim if true interim transcriptions are sent no (default: false) recognizer.language language to use for speech transcription yes recognizer.profanityFilter if true, filter profanity from speech transcription. Default: no no recognizer.vendor speech vendor to use (currently only google supported) no transcriptionHook webhook to call when a transcription is received. Due to the richness of information in the transcription an HTTP POST will always be sent. yes Note : the dualChannel property is not currently implemented.","title":"transcribe"},{"location":"jambonz/#example-messages","text":"An example JSON payload for a webhook for an incoming call using a POST method. There's a lot of detail here, because when you specify to receive a POST you are getting the full SIP INVITE. { direction : inbound , callSid : 1fe62f7c-ebb9-4b96-b75b-7d04ff2b195d , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083084809 , to : +15083728299 , callerName : +15083084809 , callId : 252a93d3-bdb2-1238-6185-06d91d68c9b0 , sipStatus : 100, callStatus : trying , originatingSipIp : 54.172.60.2:5060 , originatingSipTrunkName : twilio , sip : { headers : { via : SIP/2.0/UDP 3.10.235.99;rport=5060;branch=z9hG4bKgeBy6Fg863Z8N;received=172.31.3.33 , max-forwards : 70 , from : sip:+15083084809@3.10.235.99:5060 ;tag=vQXQ3g5papXpF , to : sip:+15083728299@172.31.3.33:5070 , call-id : 252a93d3-bdb2-1238-6185-06d91d68c9b0 , cseq : 15623387 INVITE , contact : sip:+15083084809@3.10.235.99:5060 , user-agent : Twilio Gateway , allow : INVITE, ACK, CANCEL, BYE, REFER, NOTIFY, OPTIONS , content-type : application/sdp , content-length : 264 , X-CID : f9221ea5e66a1d1f10a0b556933dc0c2@0.0.0.0 , X-Forwarded-For : 54.172.60.2:5060 , X-Originating-Carrier : twilio , Diversion : sip:+15083728299@public-vip.us1.twilio.com ;reason=unconditional }, body : v=0\\r\\no=root 1999455157 1999455157 IN IP4 3.10.235.99\\r\\ns=Twilio Media Gateway\\r\\nc=IN IP4 3.10.235.99\\r\\nt=0 0\\r\\nm=audio 49764 RTP/AVP 0 101\\r\\na=maxptime:150\\r\\na=rtpmap:0 PCMU/8000\\r\\na=rtpmap:101 telephone-event/8000\\r\\na=fmtp:101 0-16\\r\\na=sendrecv\\r\\na=rtcp:49765\\r\\na=ptime:20\\r\\n , payload : [{ type : application/sdp , content : v=0\\r\\no=root 1999455157 1999455157 IN IP4 3.10.235.99\\r\\ns=Twilio Media Gateway\\r\\nc=IN IP4 3.10.235.99\\r\\nt=0 0\\r\\nm=audio 49764 RTP/AVP 0 101\\r\\na=maxptime:150\\r\\na=rtpmap:0 PCMU/8000\\r\\na=rtpmap:101 telephone-event/8000\\r\\na=fmtp:101 0-16\\r\\na=sendrecv\\r\\na=rtcp:49765\\r\\na=ptime:20\\r\\n }], method : INVITE , version : 2.0 , uri : sip:+15083728299@172.31.3.33:5070 , raw : INVITE sip:+15083728299@172.31.3.33:5070 SIP/2.0\\r\\nVia: SIP/2.0/UDP 3.10.235.99;rport=5060;branch=z9hG4bKgeBy6Fg863Z8N;received=172.31.3.33\\r\\nMax-Forwards: 70\\r\\nFrom: sip:+15083084809@3.10.235.99:5060 ;tag=vQXQ3g5papXpF\\r\\nTo: sip:+15083728299@172.31.3.33:5070 \\r\\nCall-ID: 252a93d3-bdb2-1238-6185-06d91d68c9b0\\r\\nCSeq: 15623387 INVITE\\r\\nContact: sip:+15083084809@3.10.235.99:5060 \\r\\nUser-Agent: Twilio Gateway\\r\\nAllow: INVITE, ACK, CANCEL, BYE, REFER, NOTIFY, OPTIONS\\r\\nContent-Type: application/sdp\\r\\nContent-Length: 264\\r\\nX-CID: f9221ea5e66a1d1f10a0b556933dc0c2@0.0.0.0\\r\\nX-Forwarded-For: 54.172.60.2:5060\\r\\nX-Originating-Carrier: twilio\\r\\nDiversion: sip:+15083728299@public-vip.us1.twilio.com ;reason=unconditional\\r\\nX-Twilio-AccountSid: AC58f23d38858ac262d6ee2e554b30c561\\r\\nX-Twilio-CallSid: CA708d85d118aacfcc794b730fa02bc40c\\r\\n\\r\\nv=0\\r\\no=root 1999455157 1999455157 IN IP4 3.10.235.99\\r\\ns=Twilio Media Gateway\\r\\nc=IN IP4 3.10.235.99\\r\\nt=0 0\\r\\nm=audio 49764 RTP/AVP 0 101\\r\\na=maxptime:150\\r\\na=rtpmap:0 PCMU/8000\\r\\na=rtpmap:101 telephone-event/8000\\r\\na=fmtp:101 0-16\\r\\na=sendrecv\\r\\na=rtcp:49765\\r\\na=ptime:20\\r\\n } } An example JSON payload for a call status webhook for an incoming call using a POST method: { direction : inbound , callSid : 1fe62f7c-ebb9-4b96-b75b-7d04ff2b195d , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083084809 , to : +15083728299 , callerName : +15083084809 , callId : 252a93d3-bdb2-1238-6185-06d91d68c9b0 , sipStatus : 200, callStatus : in-progress , originatingSipIp : 54.172.60.2:5060 , originatingSipTrunkName : twilio } An example JSON payload for a call status webhook for an outbound call using a POST method: { direction : outbound , callSid : ddd6d4b2-ba3f-42fb-9845-8abdac047097 , parentCallSid : 1fe62f7c-ebb9-4b96-b75b-7d04ff2b195d , accountSid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , applicationSid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083084809 , to : +15084901000 , callerName : +15083084809 , callId : a5726393-bdaf-1238-9483-06d91d68c9b0 , callStatus : in-progress , sipStatus : 200 }","title":"Example messages"},{"location":"register-hook/","text":"Overview The platform allows sip clients to register, make and receive calls. Managing sip registrations is a shared activity between the platform and the customer application. The platform handles the sip messaging aspects, but the determination of whether to authenticate a specific request is the responsibility of the application, which is notified of incoming REGISTER requests by means of the registration webhook. This is designed so the privacy of sip credentials issued by a customer to their clients is assured; i.e. those credentials are never exposed to the platform provider entity, nor stored anywhere in the platform itself . When the platform receives an incoming sip register request, the registering sip domain is first checked to see if there is a register webhook provisioned for the that domain. If there is no webhook provisioned for that domain, a 403 Forbidden response is sent back to the client. Otherwise, the platform will challenge the REGISTER request with a 401 Unauthorized response containing a digest challenge. If the sip client then sends a REGISTER request with an Authorization header, the platform generates an http POST request to the registered webhook. The Content-Type of the POST is application/json and the body contains the following elements, as provided in the Authorization sip header of the incoming REGISTER request. { method : REGISTER , realm : example.com , username : foo , expires : 3600, nonce : InFriVGWVoKeCckYrTx7wg== , uri : sip:example.com , algorithm : MD5 , qop : auth , cnonce : 03d8d2aafd5a975f2b07dc90fe5f4100 , nc : 00000001 , response : db7b7dbec7edc0c427c1708031f67cc6 } The application, with knowledge of the password associated with the provided username and password, then performs digest authentication to authenticate the request using the information provided, including the calculated response value. Regardless of whether the request is authenticated or not, the application should respond with a 200 OK to the http POST and with a JSON body. The JSON body in the response if the request is authenticated should simply contain a status attribute with a value of ok , e.g.: { status : ok } If the application wishes to enforce a shorter expires value, it may include that value in the response, e.g.: { status : ok , expires : 1800 } The JSON body in the response if the request is not authentication should contain a status of fail , and optionally a msg attribute, e.g. { status : fail , msg : invalid password }","title":"Authenticating SIP clients"},{"location":"register-hook/#overview","text":"The platform allows sip clients to register, make and receive calls. Managing sip registrations is a shared activity between the platform and the customer application. The platform handles the sip messaging aspects, but the determination of whether to authenticate a specific request is the responsibility of the application, which is notified of incoming REGISTER requests by means of the registration webhook. This is designed so the privacy of sip credentials issued by a customer to their clients is assured; i.e. those credentials are never exposed to the platform provider entity, nor stored anywhere in the platform itself . When the platform receives an incoming sip register request, the registering sip domain is first checked to see if there is a register webhook provisioned for the that domain. If there is no webhook provisioned for that domain, a 403 Forbidden response is sent back to the client. Otherwise, the platform will challenge the REGISTER request with a 401 Unauthorized response containing a digest challenge. If the sip client then sends a REGISTER request with an Authorization header, the platform generates an http POST request to the registered webhook. The Content-Type of the POST is application/json and the body contains the following elements, as provided in the Authorization sip header of the incoming REGISTER request. { method : REGISTER , realm : example.com , username : foo , expires : 3600, nonce : InFriVGWVoKeCckYrTx7wg== , uri : sip:example.com , algorithm : MD5 , qop : auth , cnonce : 03d8d2aafd5a975f2b07dc90fe5f4100 , nc : 00000001 , response : db7b7dbec7edc0c427c1708031f67cc6 } The application, with knowledge of the password associated with the provided username and password, then performs digest authentication to authenticate the request using the information provided, including the calculated response value. Regardless of whether the request is authenticated or not, the application should respond with a 200 OK to the http POST and with a JSON body. The JSON body in the response if the request is authenticated should simply contain a status attribute with a value of ok , e.g.: { status : ok } If the application wishes to enforce a shorter expires value, it may include that value in the response, e.g.: { status : ok , expires : 1800 } The JSON body in the response if the request is not authentication should contain a status of fail , and optionally a msg attribute, e.g. { status : fail , msg : invalid password }","title":"Overview"},{"location":"rest/","text":"Overview The jambonz REST API allows applications to query, create, and manage calls and other resources. Base URL All calls should use the following base URL: https://{serviceUrl}/v1 where serviceUrl is set according to your own installation. Authentication The REST api uses HTTP Bearer Authentication which requires that you include an HTTP Authorization header containing a valid api token. Dates and Times All dates and times are UTC, using RFC 2822 format. Phone Numbers All phone numbers are in E.164 format, starting with a plus sign (\"+\") and the country code. Applications An application represents a set of unified behaviors to be applied to phone calls either made or received through the platform. Applications can be created, queried, updated, and destroyed via the API by using an api_key with Account level scope. Applications have the following properties: property description account_sid identifies the Account this application belongs to application_sid unique identifier for the application name user-specified name of application call_hook web callback to invoke for new calls call_status_hook web callback to invoke for call status notifications speech_recognizer_vendor vendor to use for speech recognition. Default: google speech_recognizer_language default language to use for speech recognition, if not specified in the 'gather' or 'transcribe' verbs. Default: en-US speech_synthesis_vendor vendor to use for text to speech. Default: google speech_synthesis_voice default voice to use for text to speech, if not specified in the 'say' verb. Default: en-US-Wavenet-C Retrieving an Application GET /v1/Applications/{ApplicationSid} curl -X GET http://{serviceUrl}/v1/Applications/0e0681b0-d49f-4fb8-b973-b5a3c6758de1 \\ -H accept: application/json \\ -H Authorization: Bearer 38700987-c7a4-4685-a5bb-af378f9734de 200 response { application_sid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , name : daveh test app , account_sid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , speech_synthesis_vendor : google , speech_synthesis_voice : en-US-Wavenet-C , speech_recognizer_vendor : google , speech_recognizer_language : en-US , call_hook : { webhook_sid : f227508f-dbb0-4fe8-a7e8-2974f54e24a1 , url : http://vibe-test.drachtio.org.ngrok.io , method : post , username : drachtio , password : 3298fn238hf9n823hf93h24398gj93n84h }, call_status_hook : { webhook_sid : 8226d33c-6a46-40d4-8fb3-02ef01199085 , url : http://vibe-test.drachtio.org.ngrok.io/callStatus , method : post , username : drachtio , password : 3298fn238hf9n823hf93h24398gj93n84h } } Listing Applications GET /v1/Applications Lists all Applications an Account (if an account scope api token is used). Deleting an Application DELETE /v1/Applications/{ApplicationSid} Deletes a specific Application. Creating an Application POST /v1/Applications Creates a new Application. Upon success, a 201 response is returned with a JSON body providing the account_sid (\"sid\") of the application that was created. curl -X POST http://{serviceUrl}/v1/Applications \\ -H accept: application/json \\ -H Authorization: Bearer 38700987-c7a4-4685-a5bb-af378f9734de \\ -H Content-Type: application/json \\ -d {\\ name\\ :\\ forward to mobile\\ ,\\ account_sid\\ :\\ fef61e75-cec3-496c-a7bc-8368e4d02a04\\ ,\\ call_hook\\ :{\\ url\\ :\\ http://vibe-test.drachtio.org.ngrok.io/mobile\\ },\\ call_status_hook\\ :{\\ url\\ :\\ http://vibe-test.drachtio.org.ngrok.io/mobileStatus\\ }} 201 response { sid : 65cddc02-6cf8-476c-97a8-1941a96e143b } Calls A call is a voice connection made between the jambonz platform and another endpoint, which may be a phone or a sip endpoint. Inbound calls are those made from external numbers or devices towards the platform, while outbound calls are placed by the platform to an endpoint. Inbound calls quite often are used to trigger outbound calls and in such a situation the outbound call will have a Parent Call Sid that references the inbound call. Calls may created, modified, and deleted through the API. Create a Call Calls are created from the REST API by sending an HTTP POST request. A successful HTTP 201 response will contain the Call Sid of the call attempt that has been launched. An example is shown below: POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls HTTP/1.1 Content-Length: 175 Accept: application/json Authorization: Bearer 9404e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { application_sid : 0e06a1b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083728299 , to : { type : phone , name : +16172375089 }, tag : { accountCode : 288fe284 } } HTTP/1.1 201 Created Content-Type: application/json; charset=utf-8 Content-Length: 46 { sid : 9210add6-9573-4860-a003-648c7829faaa } The Request-URI of the POST contains the Account Sid of the caller and JSON payload may contain the following properties property description required application_sid The unique identifier of the application used to handle the call either call_hook or application_sid must be supplied call_hook an object specifying a web callback that will be invoked when the call is answered either call_hook or application_sid must be supplied call_hook.url web callback url yes call_hook.method 'GET' or 'POST'. Defaults to 'POST' no call_hook.username username for HTTP Basic Authentication no call_hook.password password for HTTP Basic Authentication no call_status_hook an object specifying a a web callback that will be invoked with call status notifications. Object properties the same as 'call_hook' property above. no from the calling party number yes headers an object containing arbitrary sip headers to apply to the outbound call attempt no tag an object containing customer data to associate with this call; this essentially calls the tag verb for you no timeout the number of seconds to wait for the call to be answered. Defaults to 60. no to specifies the destination of the call. See description of target types in jambonz call control language. yes At the time that the 201 response is returned to the caller, the call attempt has been launched (i.e., the SIP INVITE has been sent) but no ringing or call answer has yet occurred. The caller will receive call status notifications via the call_status_hook (either that supplied in the POST request, or if an application_sid is supplied then via the configured call_status_hook for that application). Retrieving a Call GET /v1/Accounts/{AccountSid}/Calls/{CallSid} curl -X GET http://{serviceUrl}/v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/ba01d74c-397e-4c80-9c8f-d57515ca8e86 \\ -H accept: application/json \\ -H Authorization: Bearer 38700987-c7a4-4685-a5bb-af378f9734de 200 response { service_url : http://172.31.3.33:4001 , call_sid : ba01d74c-397e-4c80-9c8f-d57515ca8e86 , account_sid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , application_sid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , caller_name : +15083084809 , call_id : 95863901-c3c5-1238-6185-06d91d68c9b0 , sip_status : 200 , call_status : completed , duration : 182, originating_sip_ip : 64.172.60.1:5060 , originating_sip_trunk_name : cheaprates } Listing Calls GET /v1/Accounts/{AccountSid}/Calls Lists all Calls under an Account Deleting a Call DELETE /v1/Accounts/{AccountSid}/Calls/{CallSid} Deletes a specific Call. Updating a Call POST /v1/Accounts/{AccountSid}/Calls/{CallSid} This operation allows you to modify certain aspects of an active call (aka \"live call control\"). The JSON payload can support the following properties: property description when can this be used call_hook a new application to start executing on the call at any time a call is active call_status Change the status of the call. Possible values are 'completed' or 'no-answer' (the former terminates an answered call, the latter a call that is ringing) at any time a call is in-progress or ringing listen_status Change the status of a listen stream. Possible values are 'pause' or 'resume'. Pausing a stream maintains the websocket connection but will discontinue sending audio over the connection. Resuming will start sending audio again. This may be useful, for example, when a caller is providing confidential information that you do not want to appear in a recording. only when a listen command is active on the call (may be nested in an active dial command) mute_status Mute or unmute a call that is currently in a Dial verb. Possible values are 'mute' or 'unmute'. Either party in a call may be modified, depending on the call_sid provided in the path of the request-uri. only when a dial command is currently active on a call whisper Play a mid-call whisper prompt to one of the parties on a call in progress. The whisper prompt is provided in a play or say verb, as shown in the examples below. The whisper may be played to either party on the call, depending on the call_sid provided in the path of the request-uri. The other party is briefly placed on hold while the prompt is played, and then reconnected to the other party afterwards. only when a dial command is currently active on the call The call_status, listen_status, and mute_status properties are mutually exclusive -- only one may be provided in the same request. The whisper property may be provided alone, or together with a listen_status or mute_status property, in which case the whisper prompt is played after the listen_status or mute_status operation is complete. Finally, if call_hook is provided, then call_status_hook may also optionally be included. This is used to specify a new callback to send call status events to. The response to a successful POST is a 202 Accepted. Providing a new application POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { call_hook : { url : /transfer-to-support , } } Terminating a call POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { call_status : completed } Pausing a listen stream POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { listen_status : pause } Resuming a listen stream POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { listen_status : resume } Muting a party POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { mute_status : mute } Unmuting a party POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { mute_status : unmute } Playing a whisper prompt The content of the whisper prompt may be a single say or play verb: POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { whisper : { verb : say , text : You have two minutes remaining on your call. } } or an array of play or say verbs: POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { whisper : [{ verb : say , text : You have two minutes remaining on your call. }, { verb : say , text : Please use them wisely }] } No verb other than a play or say verb may be included. The loop property of the verb is not supported in this usage. Muting someone and then telling them about it POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { mute_status : mute , whisper : [ { verb : say , text : Your call has been muted. } ] } Management API Accounts Accounts allow a subscriber to set some useful defaults that apply to all their Applications. Accounts have the following properties: property description account_sid unique identifier for the account device_calling_hook web callback invoked when a registered sip user places a call is_active indicates whether account is active or not name account name registration_hook web callback to use to authenticate sip users/devices sip_realm the sip realm (domain) that groups all sip users within the Account Retrieving an Account GET /v1/Accounts/{AccountSid} curl -X GET https://{serviceUrl}/v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04 \\ -H accept: application/json \\ -H Authorization: Bearer 6604e5f7-9a77-42cc-b0fa-5665ace28ab3 200 response { account_sid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , name : pactolus , sip_realm : pactolus.com , service_provider_sid : a44985ae-3b03-4d23-a602-4971cfd60a65 , is_active : 1, registration_hook : { url : https://app.pactolus.com/reg }, device_calling_hook : { url : https://app.pactolus/deviceCall } } Listing Accounts GET /v1/Accounts Lists all Accounts under a Service Provider (if a service provider scope api token is used) or under all Service Providers (if an admin scope api token is used). Deleting Accounts DELETE /v1/Accounts/{AccountSid} Deletes a specific Account. Creating an Account POST /v1/Accounts Creates a new Account. This operation can only be peformed using a Service Provider or Admin scope api token. Upon success, a 201 response is returned with a JSON body providing the account_sid (\"sid\") of the account that was created. curl -X POST https://{serviceUrl}/v1/Accounts \\ -H accept: application/json \\ -H Authorization: Bearer 38702987-c7a4-4685-a5bb-af378f9734de \\ -H Content-Type: application/json \\ -d {\\ name\\ :\\ brandon's account\\ ,\\ sip_realm\\ :\\ sip.brandon.com\\ ,\\ registration_hook\\ :{\\ url\\ :\\ https://brandon.com/reg\\ ,\\ method\\ :\\ POST\\ },\\ device_calling_hook\\ :{\\ url\\ :\\ https://brandon.com/dev\\ ,\\ method\\ :\\ POST\\ },\\ service_provider_sid\\ :\\ a44985ae-3b03-4d23-a602-4971cfd60a65\\ } 201 response { sid : 65cddc02-6cf8-476c-97a8-1941a96e143b } API Key An api key is a token that is associated with an application and is used to authenticate requests on behalf of that application. Api keys can be created and destroyed via the API. API keys can have different scopes: Admin scope, service provider scope, and account scope. Admin scope allows the bearer to make changes to global system properties and to create Service Providers. Service provider scope allows the bearer to create and manage Accounts under the Service Providerxs. Account scope allows the bearer to create applications and calls associated with the Account. Conference participants Conference participants refer to calls that are actively connected to a conference. You can mute or remove participants from a conference as well as retrieve a list of all participants, along with detailed information about each participant, in an active conference. Conferences Conferences represent a common endpoint that can mix the audio from multiple calls. Conferences can be created, modified and deleted through the API. Phone numbers Phone numbers represent phone numbers that route to the jambonz platform, and may be associated with an application. A Phone number may be associated with zero or one Application. Phone numbers can be created and destroyed through the API, as well as being modified to point to a different application. Queues Queues represent an ordered collection of active calls that are parked (not connected to a far end). Queues may be created and deleted through the API. Queued calls Queued calls are calls that have been assigned to a queue.","title":"jambonz REST API"},{"location":"rest/#overview","text":"The jambonz REST API allows applications to query, create, and manage calls and other resources. Base URL All calls should use the following base URL: https://{serviceUrl}/v1 where serviceUrl is set according to your own installation. Authentication The REST api uses HTTP Bearer Authentication which requires that you include an HTTP Authorization header containing a valid api token. Dates and Times All dates and times are UTC, using RFC 2822 format. Phone Numbers All phone numbers are in E.164 format, starting with a plus sign (\"+\") and the country code.","title":"Overview"},{"location":"rest/#applications","text":"An application represents a set of unified behaviors to be applied to phone calls either made or received through the platform. Applications can be created, queried, updated, and destroyed via the API by using an api_key with Account level scope. Applications have the following properties: property description account_sid identifies the Account this application belongs to application_sid unique identifier for the application name user-specified name of application call_hook web callback to invoke for new calls call_status_hook web callback to invoke for call status notifications speech_recognizer_vendor vendor to use for speech recognition. Default: google speech_recognizer_language default language to use for speech recognition, if not specified in the 'gather' or 'transcribe' verbs. Default: en-US speech_synthesis_vendor vendor to use for text to speech. Default: google speech_synthesis_voice default voice to use for text to speech, if not specified in the 'say' verb. Default: en-US-Wavenet-C","title":"Applications"},{"location":"rest/#retrieving-an-application","text":"GET /v1/Applications/{ApplicationSid} curl -X GET http://{serviceUrl}/v1/Applications/0e0681b0-d49f-4fb8-b973-b5a3c6758de1 \\ -H accept: application/json \\ -H Authorization: Bearer 38700987-c7a4-4685-a5bb-af378f9734de 200 response { application_sid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , name : daveh test app , account_sid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , speech_synthesis_vendor : google , speech_synthesis_voice : en-US-Wavenet-C , speech_recognizer_vendor : google , speech_recognizer_language : en-US , call_hook : { webhook_sid : f227508f-dbb0-4fe8-a7e8-2974f54e24a1 , url : http://vibe-test.drachtio.org.ngrok.io , method : post , username : drachtio , password : 3298fn238hf9n823hf93h24398gj93n84h }, call_status_hook : { webhook_sid : 8226d33c-6a46-40d4-8fb3-02ef01199085 , url : http://vibe-test.drachtio.org.ngrok.io/callStatus , method : post , username : drachtio , password : 3298fn238hf9n823hf93h24398gj93n84h } }","title":"Retrieving an Application"},{"location":"rest/#listing-applications","text":"GET /v1/Applications Lists all Applications an Account (if an account scope api token is used).","title":"Listing Applications"},{"location":"rest/#deleting-an-application","text":"DELETE /v1/Applications/{ApplicationSid} Deletes a specific Application.","title":"Deleting an Application"},{"location":"rest/#creating-an-application","text":"POST /v1/Applications Creates a new Application. Upon success, a 201 response is returned with a JSON body providing the account_sid (\"sid\") of the application that was created. curl -X POST http://{serviceUrl}/v1/Applications \\ -H accept: application/json \\ -H Authorization: Bearer 38700987-c7a4-4685-a5bb-af378f9734de \\ -H Content-Type: application/json \\ -d {\\ name\\ :\\ forward to mobile\\ ,\\ account_sid\\ :\\ fef61e75-cec3-496c-a7bc-8368e4d02a04\\ ,\\ call_hook\\ :{\\ url\\ :\\ http://vibe-test.drachtio.org.ngrok.io/mobile\\ },\\ call_status_hook\\ :{\\ url\\ :\\ http://vibe-test.drachtio.org.ngrok.io/mobileStatus\\ }} 201 response { sid : 65cddc02-6cf8-476c-97a8-1941a96e143b }","title":"Creating an Application"},{"location":"rest/#calls","text":"A call is a voice connection made between the jambonz platform and another endpoint, which may be a phone or a sip endpoint. Inbound calls are those made from external numbers or devices towards the platform, while outbound calls are placed by the platform to an endpoint. Inbound calls quite often are used to trigger outbound calls and in such a situation the outbound call will have a Parent Call Sid that references the inbound call. Calls may created, modified, and deleted through the API.","title":"Calls"},{"location":"rest/#create-a-call","text":"Calls are created from the REST API by sending an HTTP POST request. A successful HTTP 201 response will contain the Call Sid of the call attempt that has been launched. An example is shown below: POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls HTTP/1.1 Content-Length: 175 Accept: application/json Authorization: Bearer 9404e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { application_sid : 0e06a1b0-d49f-4fb8-b973-b5a3c6758de1 , from : +15083728299 , to : { type : phone , name : +16172375089 }, tag : { accountCode : 288fe284 } } HTTP/1.1 201 Created Content-Type: application/json; charset=utf-8 Content-Length: 46 { sid : 9210add6-9573-4860-a003-648c7829faaa } The Request-URI of the POST contains the Account Sid of the caller and JSON payload may contain the following properties property description required application_sid The unique identifier of the application used to handle the call either call_hook or application_sid must be supplied call_hook an object specifying a web callback that will be invoked when the call is answered either call_hook or application_sid must be supplied call_hook.url web callback url yes call_hook.method 'GET' or 'POST'. Defaults to 'POST' no call_hook.username username for HTTP Basic Authentication no call_hook.password password for HTTP Basic Authentication no call_status_hook an object specifying a a web callback that will be invoked with call status notifications. Object properties the same as 'call_hook' property above. no from the calling party number yes headers an object containing arbitrary sip headers to apply to the outbound call attempt no tag an object containing customer data to associate with this call; this essentially calls the tag verb for you no timeout the number of seconds to wait for the call to be answered. Defaults to 60. no to specifies the destination of the call. See description of target types in jambonz call control language. yes At the time that the 201 response is returned to the caller, the call attempt has been launched (i.e., the SIP INVITE has been sent) but no ringing or call answer has yet occurred. The caller will receive call status notifications via the call_status_hook (either that supplied in the POST request, or if an application_sid is supplied then via the configured call_status_hook for that application).","title":"Create a Call"},{"location":"rest/#retrieving-a-call","text":"GET /v1/Accounts/{AccountSid}/Calls/{CallSid} curl -X GET http://{serviceUrl}/v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/ba01d74c-397e-4c80-9c8f-d57515ca8e86 \\ -H accept: application/json \\ -H Authorization: Bearer 38700987-c7a4-4685-a5bb-af378f9734de 200 response { service_url : http://172.31.3.33:4001 , call_sid : ba01d74c-397e-4c80-9c8f-d57515ca8e86 , account_sid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , application_sid : 0e0681b0-d49f-4fb8-b973-b5a3c6758de1 , caller_name : +15083084809 , call_id : 95863901-c3c5-1238-6185-06d91d68c9b0 , sip_status : 200 , call_status : completed , duration : 182, originating_sip_ip : 64.172.60.1:5060 , originating_sip_trunk_name : cheaprates }","title":"Retrieving a Call"},{"location":"rest/#listing-calls","text":"GET /v1/Accounts/{AccountSid}/Calls Lists all Calls under an Account","title":"Listing Calls"},{"location":"rest/#deleting-a-call","text":"DELETE /v1/Accounts/{AccountSid}/Calls/{CallSid} Deletes a specific Call.","title":"Deleting a Call"},{"location":"rest/#updating-a-call","text":"POST /v1/Accounts/{AccountSid}/Calls/{CallSid} This operation allows you to modify certain aspects of an active call (aka \"live call control\"). The JSON payload can support the following properties: property description when can this be used call_hook a new application to start executing on the call at any time a call is active call_status Change the status of the call. Possible values are 'completed' or 'no-answer' (the former terminates an answered call, the latter a call that is ringing) at any time a call is in-progress or ringing listen_status Change the status of a listen stream. Possible values are 'pause' or 'resume'. Pausing a stream maintains the websocket connection but will discontinue sending audio over the connection. Resuming will start sending audio again. This may be useful, for example, when a caller is providing confidential information that you do not want to appear in a recording. only when a listen command is active on the call (may be nested in an active dial command) mute_status Mute or unmute a call that is currently in a Dial verb. Possible values are 'mute' or 'unmute'. Either party in a call may be modified, depending on the call_sid provided in the path of the request-uri. only when a dial command is currently active on a call whisper Play a mid-call whisper prompt to one of the parties on a call in progress. The whisper prompt is provided in a play or say verb, as shown in the examples below. The whisper may be played to either party on the call, depending on the call_sid provided in the path of the request-uri. The other party is briefly placed on hold while the prompt is played, and then reconnected to the other party afterwards. only when a dial command is currently active on the call The call_status, listen_status, and mute_status properties are mutually exclusive -- only one may be provided in the same request. The whisper property may be provided alone, or together with a listen_status or mute_status property, in which case the whisper prompt is played after the listen_status or mute_status operation is complete. Finally, if call_hook is provided, then call_status_hook may also optionally be included. This is used to specify a new callback to send call status events to. The response to a successful POST is a 202 Accepted.","title":"Updating a Call"},{"location":"rest/#providing-a-new-application","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { call_hook : { url : /transfer-to-support , } }","title":"Providing a new application"},{"location":"rest/#terminating-a-call","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { call_status : completed }","title":"Terminating a call"},{"location":"rest/#pausing-a-listen-stream","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { listen_status : pause }","title":"Pausing a listen stream"},{"location":"rest/#resuming-a-listen-stream","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { listen_status : resume }","title":"Resuming a listen stream"},{"location":"rest/#muting-a-party","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { mute_status : mute }","title":"Muting a party"},{"location":"rest/#unmuting-a-party","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { mute_status : unmute }","title":"Unmuting a party"},{"location":"rest/#playing-a-whisper-prompt","text":"The content of the whisper prompt may be a single say or play verb: POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { whisper : { verb : say , text : You have two minutes remaining on your call. } } or an array of play or say verbs: POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { whisper : [{ verb : say , text : You have two minutes remaining on your call. }, { verb : say , text : Please use them wisely }] } No verb other than a play or say verb may be included. The loop property of the verb is not supported in this usage.","title":"Playing a whisper prompt"},{"location":"rest/#muting-someone-and-then-telling-them-about-it","text":"POST /v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04/Calls/bd9a8d8d-bd55-4c53-a373-929e85c6db22 HTTP/1.1 Authorization: Bearer 9604e5f7-9a77-4bcc-b0fa-5665ace28ab3 Content-Type: application/json { mute_status : mute , whisper : [ { verb : say , text : Your call has been muted. } ] }","title":"Muting someone and then telling them about it"},{"location":"rest/#management-api","text":"","title":"Management API"},{"location":"rest/#accounts","text":"Accounts allow a subscriber to set some useful defaults that apply to all their Applications. Accounts have the following properties: property description account_sid unique identifier for the account device_calling_hook web callback invoked when a registered sip user places a call is_active indicates whether account is active or not name account name registration_hook web callback to use to authenticate sip users/devices sip_realm the sip realm (domain) that groups all sip users within the Account","title":"Accounts"},{"location":"rest/#retrieving-an-account","text":"GET /v1/Accounts/{AccountSid} curl -X GET https://{serviceUrl}/v1/Accounts/fef61e75-cec3-496c-a7bc-8368e4d02a04 \\ -H accept: application/json \\ -H Authorization: Bearer 6604e5f7-9a77-42cc-b0fa-5665ace28ab3 200 response { account_sid : fef61e75-cec3-496c-a7bc-8368e4d02a04 , name : pactolus , sip_realm : pactolus.com , service_provider_sid : a44985ae-3b03-4d23-a602-4971cfd60a65 , is_active : 1, registration_hook : { url : https://app.pactolus.com/reg }, device_calling_hook : { url : https://app.pactolus/deviceCall } }","title":"Retrieving an Account"},{"location":"rest/#listing-accounts","text":"GET /v1/Accounts Lists all Accounts under a Service Provider (if a service provider scope api token is used) or under all Service Providers (if an admin scope api token is used).","title":"Listing Accounts"},{"location":"rest/#deleting-accounts","text":"DELETE /v1/Accounts/{AccountSid} Deletes a specific Account.","title":"Deleting Accounts"},{"location":"rest/#creating-an-account","text":"POST /v1/Accounts Creates a new Account. This operation can only be peformed using a Service Provider or Admin scope api token. Upon success, a 201 response is returned with a JSON body providing the account_sid (\"sid\") of the account that was created. curl -X POST https://{serviceUrl}/v1/Accounts \\ -H accept: application/json \\ -H Authorization: Bearer 38702987-c7a4-4685-a5bb-af378f9734de \\ -H Content-Type: application/json \\ -d {\\ name\\ :\\ brandon's account\\ ,\\ sip_realm\\ :\\ sip.brandon.com\\ ,\\ registration_hook\\ :{\\ url\\ :\\ https://brandon.com/reg\\ ,\\ method\\ :\\ POST\\ },\\ device_calling_hook\\ :{\\ url\\ :\\ https://brandon.com/dev\\ ,\\ method\\ :\\ POST\\ },\\ service_provider_sid\\ :\\ a44985ae-3b03-4d23-a602-4971cfd60a65\\ } 201 response { sid : 65cddc02-6cf8-476c-97a8-1941a96e143b }","title":"Creating an Account"},{"location":"rest/#api-key","text":"An api key is a token that is associated with an application and is used to authenticate requests on behalf of that application. Api keys can be created and destroyed via the API. API keys can have different scopes: Admin scope, service provider scope, and account scope. Admin scope allows the bearer to make changes to global system properties and to create Service Providers. Service provider scope allows the bearer to create and manage Accounts under the Service Providerxs. Account scope allows the bearer to create applications and calls associated with the Account.","title":"API Key"},{"location":"rest/#conference-participants","text":"Conference participants refer to calls that are actively connected to a conference. You can mute or remove participants from a conference as well as retrieve a list of all participants, along with detailed information about each participant, in an active conference.","title":"Conference participants"},{"location":"rest/#conferences","text":"Conferences represent a common endpoint that can mix the audio from multiple calls. Conferences can be created, modified and deleted through the API.","title":"Conferences"},{"location":"rest/#phone-numbers","text":"Phone numbers represent phone numbers that route to the jambonz platform, and may be associated with an application. A Phone number may be associated with zero or one Application. Phone numbers can be created and destroyed through the API, as well as being modified to point to a different application.","title":"Phone numbers"},{"location":"rest/#queues","text":"Queues represent an ordered collection of active calls that are parked (not connected to a far end). Queues may be created and deleted through the API.","title":"Queues"},{"location":"rest/#queued-calls","text":"Queued calls are calls that have been assigned to a queue.","title":"Queued calls"},{"location":"teams/","text":"Microsoft Teams Integration The instructions below assume that you are starting with a working system, and that you would like to add Microsoft Teams directing routing support. In other words, your jambonz system will act as an SBC to Microsoft Teams, providing direct routing support and allowing teams users to make and receive calls from mobile phones and landlines. These instructions cover only the changes needed on the jambonz side of things; please refer to the Microsoft docs for information regarding changes that must be made by your Teams admin to enable direct routing. Changes to the jambonz SBC Add additional listen port 5061/tls Edit the /etc/systemd/system/drachtio.service file to add a contact to listen for TLS traffic on port 5061: ExecStart=/usr/local/bin/drachtio --daemon \\ --contact sip:${LOCAL_IP};transport=udp --external-ip ${PUBLIC_IP} \\ --contact sips:${LOCAL_IP}:5061;transport=tls --external-ip ${PUBLIC_IP} \\ --contact sip:${LOCAL_IP};transport=tcp \\ --address 0.0.0.0 --port 9022 Generate TLS certificate You will need to generate a TLS certificate that has a SAN for both the SBC domain name as well as a wildcard SAN for customer tenants, which are subdomains of the SBC domain name. For instance, an SBC domain name might be teams.example.com and customer tenants could be cust1.teams.example.com , cust2.teams.example.com , etc. Generating such a TLS certificate can be done for free using letsencrypt as follows: certbot certonly --manual --preferred-challenges=dns --email me@example.com \\ --server https://acme-v02.api.letsencrypt.org/directory --agree-tos \\ -d *.teams.example.com -d teams.example.com Update drachtio config Edit /etc/drachtio.conf.xml to reference the TLS certificate, key, and chain file by adding a tls/ section within the sip/ element sip tls key-file /etc/letsencrypt/live/teams.example.com/privkey.pem /key-file cert-file /etc/letsencrypt/live/teams.example.com/cert.pem /cert-file chain-file /etc/letsencrypt/live/teams.example.com/chain.pem /chain-file /tls /sip Restart drachtio server sudo systemctl daemon-reload sudo systemctl restart drachtio Verify configuration changes Execute the command sudo systemctl status drachtio to verify that the drachtio server restarted correctly, and examine the /var/log/drachtio/drachtio.log file to verify that it is now listening on port 5061 for TLS traffic, in addition to port 5060. The log file after startup should look something like this, with logging indicating that it is now listening for tls traffic on port 5061 and has successfully loaded the TLS certificate: 2020-08-05 13:06:39.574425 Starting drachtio version v0.8.6-rc1-2-g5faa42c74 2020-08-05 13:06:39.574546 DrachtioController::run tls key file: /etc/letsencrypt/live/teams.jambonz.us/privkey.pem 2020-08-05 13:06:39.574554 DrachtioController::run tls certificate file: /etc/letsencrypt/live/teams.jambonz.us/cert.pem 2020-08-05 13:06:39.574562 DrachtioController::run tls chain file: /etc/letsencrypt/live/teams.jambonz.us/chain.pem 2020-08-05 13:06:39.580917 SipTransport::logTransports - there are : 3 transports 2020-08-05 13:06:39.580933 SipTransport::logTransports - tcp/172.31.32.10:5060 (sip:172.31.32.10;transport=tcp, external-ip: , local-net: ) 2020-08-05 13:06:39.580942 SipTransport::logTransports - tls/172.31.32.10:5061 (sips:172.31.32.10:5061;transport=tls, external-ip: 54.174.72.99, local-net: ) 2020-08-05 13:06:39.580953 SipTransport::logTransports - udp/172.31.32.10:5060 (sip:172.31.32.10;transport=udp, external-ip: 54.174.72.99, local-net: ), mtu size: 4096 Provision tenant FQDNs Log into the jambonz provisioning GUI for your system, click 'Settings' in the left sidebar menu and enable the checkbox labeled \"Enable Microsoft Teams Direct Routing\". Enter your SBC domain name (e.g. \"teams.example.com\") in the field labeled \"SBC Domain Name\" and click the Save button. Next, click \"MS Teams Tenant\" in the left sidebar menu and add at least one tenant domain (e.g., \"cust1.teams.example.com\" in the example above), associate that tenant with a jambonz account and click the \"Add Microsoft Teams Tenant\" button. Restart drachtio apps As the 'admin' user, restart the applications using pm2: pm2 restart all Verify connectivity The jambonz SBC should now be sending OPTIONS pings to Microsoft Teams every 30 seconds or so. To verify, tail the log file /var/log/drachtio.log to see the OPTIONS request being sent, and the response received. If all is working, then a 200 OK should be received as in the sample output below 2020-08-05 14:36:22.539782 send 372 bytes to tls/[52.114.148.0]:5061 at 14:36:22.539678: OPTIONS sip:sip.pstnhub.microsoft.com SIP/2.0 Via: SIP/2.0/TLS 54.174.72.99;branch=z9hG4bK1HQpp1BtBQ30N Max-Forwards: 70 From: sip:teams.jambonz.us:5061;transport=tls ;tag=SX7B39veap93c To: sip:sip.pstnhub.microsoft.com Call-ID: dfe4b29f-51cb-1239-3b99-06ce423ffcdb CSeq: 23765299 OPTIONS Contact: sip:teams.jambonz.us:5061;transport=tls Content-Length: 0 2020-08-05 14:36:22.564556 recv 376 bytes from tls/[52.114.148.0]:5061 at 14:36:22.564475: SIP/2.0 200 OK FROM: sip:teams.jambonz.us:5061;transport=tls ;tag=SX7B39veap93c TO: sip:sip.pstnhub.microsoft.com CSEQ: 23765299 OPTIONS CALL-ID: dfe4b29f-51cb-1239-3b99-06ce423ffcdb VIA: SIP/2.0/TLS 54.174.72.99;branch=z9hG4bK1HQpp1BtBQ30N CONTENT-LENGTH: 0 ALLOW: INVITE,ACK,OPTIONS,CANCEL,BYE,NOTIFY SERVER: Microsoft.PSTNHub.SIPProxy v.2020.7.31.1 i.USWE2.3 At this point, once the necessary configuration changes have been made in Microsoft Teams admin, you should be able to test sending and receiving calls. To test, create a simple app of some kind and assign it as the outbound calling application for the customer tenant by going into the jambonz provisioning GUI, clicking \"MS Teams Tenant\" and modifying the customer tenant to associate the application to this tenant. Any outbound calls from the tenant will now execute the selected application.","title":"Microsoft Teams"},{"location":"teams/#microsoft-teams-integration","text":"The instructions below assume that you are starting with a working system, and that you would like to add Microsoft Teams directing routing support. In other words, your jambonz system will act as an SBC to Microsoft Teams, providing direct routing support and allowing teams users to make and receive calls from mobile phones and landlines. These instructions cover only the changes needed on the jambonz side of things; please refer to the Microsoft docs for information regarding changes that must be made by your Teams admin to enable direct routing.","title":"Microsoft Teams Integration"},{"location":"teams/#changes-to-the-jambonz-sbc","text":"","title":"Changes to the jambonz SBC"},{"location":"teams/#add-additional-listen-port-5061tls","text":"Edit the /etc/systemd/system/drachtio.service file to add a contact to listen for TLS traffic on port 5061: ExecStart=/usr/local/bin/drachtio --daemon \\ --contact sip:${LOCAL_IP};transport=udp --external-ip ${PUBLIC_IP} \\ --contact sips:${LOCAL_IP}:5061;transport=tls --external-ip ${PUBLIC_IP} \\ --contact sip:${LOCAL_IP};transport=tcp \\ --address 0.0.0.0 --port 9022","title":"Add additional listen port 5061/tls"},{"location":"teams/#generate-tls-certificate","text":"You will need to generate a TLS certificate that has a SAN for both the SBC domain name as well as a wildcard SAN for customer tenants, which are subdomains of the SBC domain name. For instance, an SBC domain name might be teams.example.com and customer tenants could be cust1.teams.example.com , cust2.teams.example.com , etc. Generating such a TLS certificate can be done for free using letsencrypt as follows: certbot certonly --manual --preferred-challenges=dns --email me@example.com \\ --server https://acme-v02.api.letsencrypt.org/directory --agree-tos \\ -d *.teams.example.com -d teams.example.com","title":"Generate TLS certificate"},{"location":"teams/#update-drachtio-config","text":"Edit /etc/drachtio.conf.xml to reference the TLS certificate, key, and chain file by adding a tls/ section within the sip/ element sip tls key-file /etc/letsencrypt/live/teams.example.com/privkey.pem /key-file cert-file /etc/letsencrypt/live/teams.example.com/cert.pem /cert-file chain-file /etc/letsencrypt/live/teams.example.com/chain.pem /chain-file /tls /sip","title":"Update drachtio config"},{"location":"teams/#restart-drachtio-server","text":"sudo systemctl daemon-reload sudo systemctl restart drachtio","title":"Restart drachtio server"},{"location":"teams/#verify-configuration-changes","text":"Execute the command sudo systemctl status drachtio to verify that the drachtio server restarted correctly, and examine the /var/log/drachtio/drachtio.log file to verify that it is now listening on port 5061 for TLS traffic, in addition to port 5060. The log file after startup should look something like this, with logging indicating that it is now listening for tls traffic on port 5061 and has successfully loaded the TLS certificate: 2020-08-05 13:06:39.574425 Starting drachtio version v0.8.6-rc1-2-g5faa42c74 2020-08-05 13:06:39.574546 DrachtioController::run tls key file: /etc/letsencrypt/live/teams.jambonz.us/privkey.pem 2020-08-05 13:06:39.574554 DrachtioController::run tls certificate file: /etc/letsencrypt/live/teams.jambonz.us/cert.pem 2020-08-05 13:06:39.574562 DrachtioController::run tls chain file: /etc/letsencrypt/live/teams.jambonz.us/chain.pem 2020-08-05 13:06:39.580917 SipTransport::logTransports - there are : 3 transports 2020-08-05 13:06:39.580933 SipTransport::logTransports - tcp/172.31.32.10:5060 (sip:172.31.32.10;transport=tcp, external-ip: , local-net: ) 2020-08-05 13:06:39.580942 SipTransport::logTransports - tls/172.31.32.10:5061 (sips:172.31.32.10:5061;transport=tls, external-ip: 54.174.72.99, local-net: ) 2020-08-05 13:06:39.580953 SipTransport::logTransports - udp/172.31.32.10:5060 (sip:172.31.32.10;transport=udp, external-ip: 54.174.72.99, local-net: ), mtu size: 4096","title":"Verify configuration changes"},{"location":"teams/#provision-tenant-fqdns","text":"Log into the jambonz provisioning GUI for your system, click 'Settings' in the left sidebar menu and enable the checkbox labeled \"Enable Microsoft Teams Direct Routing\". Enter your SBC domain name (e.g. \"teams.example.com\") in the field labeled \"SBC Domain Name\" and click the Save button. Next, click \"MS Teams Tenant\" in the left sidebar menu and add at least one tenant domain (e.g., \"cust1.teams.example.com\" in the example above), associate that tenant with a jambonz account and click the \"Add Microsoft Teams Tenant\" button.","title":"Provision tenant FQDNs"},{"location":"teams/#restart-drachtio-apps","text":"As the 'admin' user, restart the applications using pm2: pm2 restart all","title":"Restart drachtio apps"},{"location":"teams/#verify-connectivity","text":"The jambonz SBC should now be sending OPTIONS pings to Microsoft Teams every 30 seconds or so. To verify, tail the log file /var/log/drachtio.log to see the OPTIONS request being sent, and the response received. If all is working, then a 200 OK should be received as in the sample output below 2020-08-05 14:36:22.539782 send 372 bytes to tls/[52.114.148.0]:5061 at 14:36:22.539678: OPTIONS sip:sip.pstnhub.microsoft.com SIP/2.0 Via: SIP/2.0/TLS 54.174.72.99;branch=z9hG4bK1HQpp1BtBQ30N Max-Forwards: 70 From: sip:teams.jambonz.us:5061;transport=tls ;tag=SX7B39veap93c To: sip:sip.pstnhub.microsoft.com Call-ID: dfe4b29f-51cb-1239-3b99-06ce423ffcdb CSeq: 23765299 OPTIONS Contact: sip:teams.jambonz.us:5061;transport=tls Content-Length: 0 2020-08-05 14:36:22.564556 recv 376 bytes from tls/[52.114.148.0]:5061 at 14:36:22.564475: SIP/2.0 200 OK FROM: sip:teams.jambonz.us:5061;transport=tls ;tag=SX7B39veap93c TO: sip:sip.pstnhub.microsoft.com CSEQ: 23765299 OPTIONS CALL-ID: dfe4b29f-51cb-1239-3b99-06ce423ffcdb VIA: SIP/2.0/TLS 54.174.72.99;branch=z9hG4bK1HQpp1BtBQ30N CONTENT-LENGTH: 0 ALLOW: INVITE,ACK,OPTIONS,CANCEL,BYE,NOTIFY SERVER: Microsoft.PSTNHub.SIPProxy v.2020.7.31.1 i.USWE2.3 At this point, once the necessary configuration changes have been made in Microsoft Teams admin, you should be able to test sending and receiving calls. To test, create a simple app of some kind and assign it as the outbound calling application for the customer tenant by going into the jambonz provisioning GUI, clicking \"MS Teams Tenant\" and modifying the customer tenant to associate the application to this tenant. Any outbound calls from the tenant will now execute the selected application.","title":"Verify connectivity"},{"location":"tutorials/","text":"Tutorials Quickstart: Deploying jambonz on AWS in 10 minutes or less This video shows how to use the terraform scripts provided in the github jambonz-infrastructure project to quickly create a running jambonz system on AWS. Integrating with SIP Trunking Providers Voxbone Voxbone is a SIP trunking provider that provides local DIDs (aka phone numbers) and SIP trunking in many countries around the world. They have a global presence and bring in-depth knowledge of local regulatory requirements, so they do the heavy lifting that enables you to easily acquire phone numbers in many different countries. This first video shows how to configure your Voxbone DIDs to route to jambonz. This video shows how to use the Voxbone \"Voxout\" service to place outbound calls from jambonz through Voxbone. 382 Communications 382 comm is a US-based SIP trunking and DID provider that provides great rates and customer support. This video shows how to integrate jambonz with SIP trunks from 382 commm. Building jambonz apps using Node-RED Getting started This first video provides a quickstart on building jambonz apps using the open source, drag and drop Node-RED server . Building speech-driven applications using jambonz and Node-RED This video provides an introduction into how to build speech-driven applications in jambonz Building voicebots using jambonz and dialogflow This video shows how to connect calls to dialogflow using jambonz. dialogflow part 2 - adding call transfer functionality dialogflow part 3 - building agent assist functionality","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#quickstart-deploying-jambonz-on-aws-in-10-minutes-or-less","text":"This video shows how to use the terraform scripts provided in the github jambonz-infrastructure project to quickly create a running jambonz system on AWS.","title":"Quickstart: Deploying jambonz on AWS in 10 minutes or less"},{"location":"tutorials/#integrating-with-sip-trunking-providers","text":"","title":"Integrating with SIP Trunking Providers"},{"location":"tutorials/#voxbone","text":"Voxbone is a SIP trunking provider that provides local DIDs (aka phone numbers) and SIP trunking in many countries around the world. They have a global presence and bring in-depth knowledge of local regulatory requirements, so they do the heavy lifting that enables you to easily acquire phone numbers in many different countries. This first video shows how to configure your Voxbone DIDs to route to jambonz. This video shows how to use the Voxbone \"Voxout\" service to place outbound calls from jambonz through Voxbone.","title":"Voxbone"},{"location":"tutorials/#382-communications","text":"382 comm is a US-based SIP trunking and DID provider that provides great rates and customer support. This video shows how to integrate jambonz with SIP trunks from 382 commm.","title":"382 Communications"},{"location":"tutorials/#building-jambonz-apps-using-node-red","text":"","title":"Building jambonz apps using Node-RED"},{"location":"tutorials/#getting-started","text":"This first video provides a quickstart on building jambonz apps using the open source, drag and drop Node-RED server .","title":"Getting started"},{"location":"tutorials/#building-speech-driven-applications-using-jambonz-and-node-red","text":"This video provides an introduction into how to build speech-driven applications in jambonz","title":"Building speech-driven applications using jambonz and Node-RED"},{"location":"tutorials/#building-voicebots-using-jambonz-and-dialogflow","text":"This video shows how to connect calls to dialogflow using jambonz.","title":"Building voicebots using jambonz and dialogflow"},{"location":"tutorials/#dialogflow-part-2-adding-call-transfer-functionality","text":"","title":"dialogflow part 2 - adding call transfer functionality"},{"location":"tutorials/#dialogflow-part-3-building-agent-assist-functionality","text":"","title":"dialogflow part 3 - building agent assist functionality"}]}